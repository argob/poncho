{"version":3,"file":"opening_hours.min.js","sources":["../src/locales/core.js","../src/index.js"],"sourcesContent":["import i18next from 'i18next';\nexport default i18next;\n\nimport opening_hours_resources from './opening_hours_resources.yaml';\n\nif (!i18next.isInitialized) {\n    i18next.init({\n        fallbackLng: 'en',\n        // lngWhitelist: ['en', 'de'],\n        resources: opening_hours_resources,\n        getAsync: true,\n        useCookie: true,\n        // debug: true,\n    });\n} else {\n    // compat with an app that already initializes i18n\n    for (const lang in opening_hours_resources) {\n        i18next.addResourceBundle(lang, 'opening_hours', opening_hours_resources[lang]['opening_hours'], true);\n    }\n}\n","/*\n * SPDX-FileCopyrightText: © 2013 Robin Schneider <ypid@riseup.net>\n *\n * SPDX-License-Identifier: LGPL-3.0-only\n *\n * This file is based on work under the following copyright and\n * BSD-2-Clause permission notice:\n *\n *     SPDX-FileCopyrightText: © 2012 Dmitry Marakasov <amdmi3@amdmi3.ru>\n *     All rights reserved.\n *\n *     Redistribution and use in source and binary forms, with or without\n *     modification, are permitted provided that the following conditions are met:\n *\n *     1. Redistributions of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n *\n *     2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n *     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n *     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n *     DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n *     SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n *     CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n *     OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n *     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nimport * as holiday_definitions from './holidays/index';\nimport word_error_correction from './locales/word_error_correction.yaml';\nimport lang from './locales/lang.yaml';\n\nimport SunCalc from 'suncalc';\nimport i18next from './locales/core';\n\nexport default function(value, nominatim_object, optional_conf_parm) {\n    // Short constants {{{\n    const word_value_replacement = { // If the correct values can not be calculated.\n        dawn    : 60 * 5 + 30,\n        sunrise : 60 * 6,\n        sunset  : 60 * 18,\n        dusk    : 60 * 18 + 30,\n    };\n    const months   = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];\n    const weekdays = ['Su','Mo','Tu','We','Th','Fr','Sa'];\n    const string_to_token_map = {\n        'su': [ 0, 'weekday' ],\n        'mo': [ 1, 'weekday' ],\n        'tu': [ 2, 'weekday' ],\n        'we': [ 3, 'weekday' ],\n        'th': [ 4, 'weekday' ],\n        'fr': [ 5, 'weekday' ],\n        'sa': [ 6, 'weekday' ],\n        'jan': [  0, 'month' ],\n        'feb': [  1, 'month' ],\n        'mar': [  2, 'month' ],\n        'apr': [  3, 'month' ],\n        'may': [  4, 'month' ],\n        'jun': [  5, 'month' ],\n        'jul': [  6, 'month' ],\n        'aug': [  7, 'month' ],\n        'sep': [  8, 'month' ],\n        'oct': [  9, 'month' ],\n        'nov': [ 10, 'month' ],\n        'dec': [ 11, 'month' ],\n        'day': [ 'day', 'calcday' ],\n        'days': [ 'days', 'calcday' ],\n        'sunrise': [ 'sunrise', 'timevar' ],\n        'sunset': [ 'sunset', 'timevar' ],\n        'dawn': [ 'dawn', 'timevar' ],\n        'dusk': [ 'dusk', 'timevar' ],\n        'easter': [ 'easter', 'event' ],\n        'week': [ 'week', 'week' ],\n        'open': [ 'open', 'state' ],\n        'closed': [ 'closed', 'state' ],\n        'off': [ 'off', 'state' ],\n        'unknown': [ 'unknown', 'state' ],\n    }\n\n    const default_prettify_conf = {\n        // Update README.md if changed.\n        'zero_pad_hour': true,           // enforce (\"%02d\", hour)\n        'one_zero_if_hour_zero': false,  // only one zero \"0\" if hour is zero \"0\"\n        'leave_off_closed': true,        // leave keywords \"off\" and \"closed\" as is\n        'keyword_for_off_closed': 'off', // use given keyword instead of \"off\" or \"closed\"\n        'rule_sep_string': ' ',          // separate rules by string\n        'print_semicolon': true,         // print token which separates normal rules\n        'leave_weekday_sep_one_day_betw': true, // use the separator (either \",\" or \"-\" which is used to separate days which follow to each other like Sa,Su or Su-Mo\n        'sep_one_day_between': ',',      // separator which should be used\n        'zero_pad_month_and_week_numbers': true, // Format week (e.g. `week 01`) and month day numbers (e.g. `Jan 01`) with \"%02d\".\n        'locale': 'en',                  // use local language (needs i18next)\n        'date_format': 'short'           // Use short or long date format (for day and month names)\n    };\n\n    const osm_tag_defaults = {\n        'opening_hours'       :  { 'mode' :  0, 'warn_for_PH_missing' :  true, },\n        'collection_times'    :  { 'mode' :  2, },\n        /* oh_mode 2: \"including the hyphen because there are post boxes which are\n         * emptied several (undefined) times or one (undefined) time in a certain time\n         * frame. This shall be covered also.\".\n         * Ref: https://wiki.openstreetmap.org/wiki/Key:collection_times */\n        'opening_hours:.+'    :  { 'mode' :  0, },\n        '.+:opening_hours'    :  { 'mode' :  0, },\n        '.+:opening_hours:.+' :  { 'mode' :  0, },\n        'smoking_hours'       :  { 'mode' :  0, },\n        'service_times'       :  { 'mode' :  2, },\n        'happy_hours'         :  { 'mode' :  0, },\n        'lit'                 :  { 'mode' :  0,\n            map: {\n                'yes'      : 'sunset-sunrise open \"specified as yes: At night (unknown time schedule or daylight detection)\"',\n                'automatic': 'unknown \"specified as automatic: When someone enters the way the lights are turned on.\"',\n                'no'       : 'off \"specified as no: There are no lights installed.\"',\n                'interval' : 'unknown \"specified as interval\"',\n                'limited'  : 'unknown \"specified as limited\"',\n            }\n        },\n    };\n\n    const minutes_in_day = 60 * 24;\n    const msec_in_day    = 1000 * 60 * minutes_in_day;\n    // let msec_in_week   = msec_in_day * 7;\n\n    const library_name   = 'opening_hours.js';\n    const repository_url = 'https://github.com/opening-hours/' + library_name;\n    // let issues_url     = repository_url + '/issues?state=open';\n    /* }}} */\n\n    /* Translation function {{{ */\n    /* Roughly compatibly to i18next so we can replace everything by i18next with\n     * sprintf support.\n     */\n    let locale = 'en'; // Default locale\n    if (typeof i18next === 'object') {\n        locale = i18next.language;\n    }\n\n    const t = function(str, variables) {\n        if (\n                typeof i18next === 'object'\n                && typeof i18next.t === 'function'\n                && typeof locale === 'string'\n                && ['de'].indexOf(locale) !== -1\n            ) {\n\n            let translatorFunction;\n            if (i18next.language !== locale) {\n                translatorFunction = i18next.getFixedT(locale);\n            } else {\n                translatorFunction = i18next.t;\n            }\n            const text = translatorFunction('opening_hours:texts.' + str, variables);\n            return text;\n        }\n        let text = lang[str];\n        if (typeof text === 'undefined') {\n            text = str;\n        }\n        return text.replace(/{{([^{}]*)}}/g, function (match, c) {\n            return typeof variables[c] !== 'undefined'\n                ? variables[c]\n                : match\n                ;\n            }\n        );\n    };\n    /* }}} */\n\n    /* Optional constructor parameters {{{ */\n\n    /* nominatim_object {{{\n     *\n     * Required to reasonably calculate 'sunrise' and holidays.\n     */\n    let location_cc, location_state, lat, lon;\n    if (typeof nominatim_object === 'object' && nominatim_object !== null) {\n        if (typeof nominatim_object.address === 'object') {\n            if (typeof nominatim_object.address.country_code === 'string') {\n                location_cc = nominatim_object.address.country_code;\n            }\n            if (typeof nominatim_object.address.state === 'string') {\n                location_state = nominatim_object.address.state;\n            } else if (typeof nominatim_object.address.county === 'string') {\n                location_state = nominatim_object.address.county;\n            }\n        }\n\n        if (typeof nominatim_object.lon === 'string' && typeof nominatim_object.lat === 'string') {\n            lat = nominatim_object.lat;\n            lon = nominatim_object.lon;\n        }\n    } else if (nominatim_object === null) {\n        /* Set the location to some random value. This can be used if you don’t\n         * care about correct opening hours for more complex opening_hours\n         * values.\n         */\n        location_cc = 'de';\n        location_state = 'Baden-W\\u00fcrttemberg';\n        lat = '49.5400039';\n        lon = '9.7937133';\n    } else if (typeof nominatim_object !== 'undefined') {\n        throw 'The nominatim_object parameter is of unknown type.'\n            + ' Given ' + typeof(nominatim_object)\n            + ', expected object.';\n    }\n    /* }}} */\n\n    /* mode, locale, warnings_severity, tag_key, map_value {{{\n     *\n     * 0: time ranges (default), tags: opening_hours, lit, …\n     * 1: points in time\n     * 2: both (time ranges and points in time), tags: collection_times, service_times\n     */\n\n    let warnings_severity = 4;\n    /* Default, currently the highest severity supported.\n     * This number is expected to be >= 4. This is not explicitly checked.\n     */\n\n    let oh_mode;\n    let oh_map_value = false;\n    let oh_key, oh_regex_key;\n\n    if (typeof optional_conf_parm === 'number') {\n        oh_mode = optional_conf_parm;\n    } else if (typeof optional_conf_parm === 'object') {\n        if (typeof optional_conf_parm['locale'] === 'string') {\n            /* TODO: The split thing is obviously a workaround. */\n            locale = optional_conf_parm['locale'].split('-')[0];\n        }\n        if (checkOptionalConfParm('mode', 'number')) {\n            oh_mode = optional_conf_parm['mode'];\n        }\n        if (checkOptionalConfParm('warnings_severity', 'number')) {\n            warnings_severity = optional_conf_parm['warnings_severity'];\n            if ([ 0, 1, 2, 3, 4, 5, 6, 7 ].indexOf(warnings_severity) === -1) {\n                throw t('warnings severity', { 'severity': warnings_severity, 'allowed': '[ 0, 1, 2, 3, 4, 5, 6, 7 ]' });\n            }\n        }\n        if (checkOptionalConfParm('tag_key', 'string')) {\n            oh_key = optional_conf_parm['tag_key'];\n        }\n        if (checkOptionalConfParm('map_value', 'boolean')) {\n            oh_map_value = optional_conf_parm.map_value;\n        }\n    } else if (typeof optional_conf_parm !== 'undefined') {\n        throw t('optional conf parm type', { 'given': typeof(optional_conf_parm) });\n    }\n\n    if (typeof oh_key === 'string') {\n        oh_regex_key = getRegexKeyForKeyFromOsmDefaults(oh_key)\n\n        if (oh_map_value\n            && typeof osm_tag_defaults[oh_regex_key] === 'object'\n            && typeof osm_tag_defaults[oh_regex_key]['map'] === 'object'\n            && typeof osm_tag_defaults[oh_regex_key]['map'][value] === 'string'\n            ) {\n\n            value = osm_tag_defaults[oh_regex_key]['map'][value];\n        }\n    } else if (oh_map_value) {\n        throw t('conf param tag key missing');\n    }\n\n    if (typeof oh_mode === 'undefined') {\n        if (typeof oh_key === 'string' && osm_tag_defaults[oh_regex_key] !== undefined) {\n            if (typeof osm_tag_defaults[oh_regex_key]['mode'] === 'number') {\n                oh_mode = osm_tag_defaults[oh_regex_key]['mode'];\n            } else {\n                oh_mode = 0;\n            }\n        } else {\n            oh_mode = 0;\n        }\n    } else if ([ 0, 1, 2 ].indexOf(oh_mode) === -1) {\n        throw t('conf param mode invalid', { 'given': oh_mode, 'allowed': '[ 0, 1, 2 ]' });\n    }\n\n    /* }}} */\n    /* }}} */\n\n    // Tokenize value and generate selector functions. {{{\n    if (typeof value !== 'string') {\n        throw t('no string');\n    }\n    if (/^(?:\\s*;?)+$/.test(value)) {\n        throw t('nothing');\n    }\n\n    const parsing_warnings = []; // Elements are fed into function formatWarnErrorMessage(nrule, at, message)\n    let done_with_warnings = false; // The functions which returns warnings can be called multiple times.\n    let done_with_selector_reordering = false;\n    let done_with_selector_reordering_warnings = false;\n    // eslint-disable-next-line no-var\n    var tokens = tokenize(value); // TODO: Figure out why tests fail if this is const or let.\n    // console.log(JSON.stringify(tokens, null, '    '));\n    let prettified_value = '';\n    let week_stable = true;\n\n    let rule, nrule;\n    const rules = [];\n    const rule_infos = {};\n    /* Not reliable because tokens !== new_tokens */\n    // for (var nrule = 0; nrule < tokens.length; nrule++) {\n    //     rule_infos[nrule] = {};\n    // }\n    const new_tokens = [];\n\n    for (nrule = 0; nrule < tokens.length; nrule++) {\n        if (tokens[nrule][0].length === 0) {\n            // Rule does contain nothing useful e.g. second rule of '10:00-12:00;' (empty) which needs to be handled.\n            parsing_warnings.push([nrule, -1,\n                t('nothing useful')\n                + (nrule === tokens.length - 1 && nrule > 0 && !tokens[nrule][1] ?\n                    ' ' + t('programmers joke') : '')\n                ]);\n            continue;\n        }\n\n        let continue_at = 0;\n        let next_rule_is_additional = false;\n\n        do {\n            if (continue_at === tokens[nrule][0].length) {\n                /* Additional rule does contain nothing useful e.g. second rule\n                 * of '10:00-12:00,' (empty) which needs to be handled.\n                  */\n                break;\n            }\n\n            rule = {\n                // Time selectors\n                time: [],\n\n                // Temporary array of selectors from time wrapped to the next day\n                wraptime: [],\n\n                // Date selectors\n                weekday: [],\n                holiday: [],\n                week: [],\n                month: [],\n                monthday: [],\n                year: [],\n\n                // Array with non-empty date selector types, with most optimal ordering\n                date: [],\n\n                fallback: tokens[nrule][1],\n                additional: continue_at ? true : false,\n                meaning: true,\n                unknown: false,\n                comment: undefined,\n                build_from_token_rule: undefined,\n            };\n\n            rule.build_from_token_rule = [ nrule, continue_at, new_tokens.length ];\n            continue_at = parseGroup(tokens[nrule][0], continue_at, rule, nrule);\n            if (typeof continue_at === 'object') {\n                continue_at = continue_at[0];\n            } else {\n                continue_at = 0;\n            }\n\n            // console.log('Current tokens: ' + JSON.stringify(tokens[nrule], null, '    '));\n\n            new_tokens.push(\n                [\n                    tokens[nrule][0].slice(\n                        rule.build_from_token_rule[1],\n                        continue_at === 0\n                            ? tokens[nrule][0].length\n                            : continue_at\n                    ),\n                    tokens[nrule][1],\n                    tokens[nrule][2],\n                ]\n            );\n\n            if (next_rule_is_additional && new_tokens.length > 1) {\n                // Move 'rule separator' from last token of last rule to first token of this rule.\n                new_tokens[new_tokens.length - 1][0].unshift(new_tokens[new_tokens.length - 2][0].pop());\n            }\n\n            next_rule_is_additional = continue_at === 0 ? false : true;\n\n            const optimal_selector_order = ['year', 'holiday', 'month', 'monthday', 'week', 'weekday'];\n            optimal_selector_order.forEach(function (element) {\n                if (rule[element].length > 0) {\n                    rule.date.push(rule[element]);\n                    rule[element] = [];\n                }\n            });\n\n            // console.log('Rule: ' + JSON.stringify(rule, null, '    '));\n            rules.push(rule);\n\n            /* This handles selectors with time ranges wrapping over midnight (e.g. 10:00-02:00).\n             * It generates wrappers for all selectors and creates a new rule.\n             */\n            if (rule.wraptime.length > 0) {\n                const wrapselectors = {\n                    time: rule.wraptime,\n                    date: [],\n\n                    meaning: rule.meaning,\n                    unknown: rule.unknown,\n                    comment: rule.comment,\n\n                    wrapped: true,\n                    build_from_token_rule: rule.build_from_token_rule,\n                };\n\n                for (let dselg = 0; dselg < rule.date.length; dselg++) {\n                    wrapselectors.date.push([]);\n                    for (let dsel = 0; dsel < rule.date[dselg].length; dsel++) {\n                        wrapselectors.date[wrapselectors.date.length-1].push(\n                                generateDateShifter(rule.date[dselg][dsel], -msec_in_day)\n                            );\n                    }\n                }\n\n                rules.push(wrapselectors);\n            }\n        } while (continue_at);\n    }\n    // console.log(JSON.stringify(tokens, null, '    '));\n    // console.log(JSON.stringify(new_tokens, null, '    '));\n    /* }}} */\n\n    /* Helper functions {{{ */\n    /* Get regex string key from key osm_tag_defaults. {{{\n     *\n     * :param key: Tag key e.g. opening_hours:kitchen.\n     * :returns: Regex key from osm_tag_defaults e.g. opening_hours:.*\n     */\n    function getRegexKeyForKeyFromOsmDefaults(key) {\n        let regex_key;\n        let exact_match = false;\n\n        Object.keys(osm_tag_defaults).forEach(function (osm_key) {\n            if (exact_match === true) {\n                return;\n            }\n            if (key === osm_key) { // Exact match.\n                regex_key = osm_key;\n                // We can't just return here as some old browsers\n                // don't interpret it as a final return (like a loop break)\n                exact_match = true;\n            } else if (new RegExp(osm_key).test(key)) {\n                regex_key = osm_key;\n            }\n        });\n        return regex_key;\n    }\n    /* }}} */\n\n    /* Check given element in optional_conf_parm. {{{\n     *\n     * :param key: Key of optional_conf_parm.\n     * :param expected_type: Expected `typeof()` the parameter.\n     * :returns: True if the expected type matches the given type.\n     */\n    function checkOptionalConfParm(key, expected_type) {\n        if (typeof optional_conf_parm[key] === expected_type) {\n            return true;\n        } else if (typeof optional_conf_parm[key] !== 'undefined') {\n            throw t('conf param unknown type', { 'key': key, 'given': typeof(optional_conf_parm[key]), 'expected': expected_type });\n        }\n        return false;\n    }\n    /* }}} */\n    /* }}} */\n\n    /* Format warning or error message for the user. {{{\n     *\n     * :param nrule: Rule number starting with 0.\n     * :param at: Token position at which the issue occurred.\n     * :param message: Human readable string with the message.\n     * :param tokens_to_use: List of token objects.\n     * :returns: String with position of the warning or error marked for the user.\n     */\n    function formatWarnErrorMessage(nrule, at, message, tokens_to_use) {\n        if (typeof tokens_to_use === 'undefined') {\n            tokens_to_use = tokens;\n        }\n        // console.log(`Called formatWarnErrorMessage: ${nrule}, ${at}, ${message}`);\n        // FIXME: Change to new_tokens.\n        if (typeof nrule === 'number') {\n            let pos = 0;\n            if (nrule === -1) { // Usage of rule index not required because we do have access to value.length.\n                pos = value.length - at;\n            } else { // Issue occurred at a later time, position in string needs to be reconstructed.\n                if (typeof tokens_to_use[nrule][0][at] === 'undefined') {\n                    if (typeof tokens_to_use[nrule][0] !== 'undefined' && at === -1) {\n                        pos = value.length;\n                        if (typeof tokens_to_use[nrule+1] === 'object' && typeof tokens_to_use[nrule+1][2] === 'number') {\n                            pos -= tokens_to_use[nrule+1][2];\n                        } else if (typeof tokens_to_use[nrule][2] === 'number') {\n                            pos -= tokens_to_use[nrule][2];\n                        }\n                    } else {\n                        // Given position is invalid.\n                        //\n                        formatLibraryBugMessage('Bug in warning generation code which could not determine the exact position of the warning or error in value.');\n                        pos = value.length;\n                        if (typeof tokens_to_use[nrule][2] === 'number') {\n                            // Fallback: Point to last token in the rule which caused the problem.\n                            // Run real_test regularly to fix the problem before a user is confronted with it.\n                            pos -= tokens_to_use[nrule][2];\n                            console.warn('Last token for rule: ' + JSON.stringify(tokens_to_use[nrule]));\n                            console.log(value.substring(0, pos) + ' <--- (' + message + ')');\n                            console.log('\\n');\n                        } {\n                            console.warn('tokens_to_use[nrule][2] is undefined. This is ok if nrule is the last rule.');\n                        }\n                    }\n                } else {\n                    pos = value.length;\n                    if (typeof tokens_to_use[nrule][0][at+1] === 'object') {\n                        pos -= tokens_to_use[nrule][0][at+1][2];\n                    } else if (typeof tokens_to_use[nrule][2] === 'number') {\n                        pos -= tokens_to_use[nrule][2];\n                    }\n                }\n            }\n            return value.substring(0, pos) + ' <--- (' + message + ')';\n        } else if (typeof nrule === 'string') {\n            return nrule.substring(0, at) + ' <--- (' + message + ')';\n        }\n    }\n    /* }}} */\n\n    /* Format internal library error message. {{{\n     *\n     * :param message: Human readable string with the error message.\n     * :param text_template: Message template defined in the `lang` variable to use for the error message. Defaults to 'library bug'.\n     * :returns: Error message for the user.\n     */\n    function formatLibraryBugMessage(message, text_template) {\n        if (typeof message === 'undefined') {\n            message = '';\n        } else {\n            message = ' ' + message;\n        }\n        if (typeof text_template !== 'string') {\n            text_template = 'library bug';\n        }\n\n        message = t(text_template, { 'value': value, 'url': repository_url, 'message': message });\n        console.error(message);\n        return message;\n    } /* }}} */\n\n    /* Tokenize input stream {{{\n     *\n     * :param value: Raw opening_hours value.\n     * :returns: Tokenized list object. Complex structure. Check the\n     *        internal documentation in the docs/ directory for details.\n     */\n    function tokenize(value) {\n        const all_tokens     = [];\n        let curr_rule_tokens = [];\n\n        let last_rule_fallback_terminated = false;\n\n        while (value !== '') {\n            /* Ordered after likelihood of input for performance reasons.\n             * Also, error tolerance is supposed to happen at the end.\n             */\n            // console.log(\"Parsing value: \" + value);\n            let tmp = value.match(/^([a-z]{2,})\\b((?:[.]| before| after)?)/i);\n            let token_from_map = undefined;\n            if (tmp && tmp[2] === '') {\n                token_from_map = string_to_token_map[tmp[1].toLowerCase()];\n            }\n            if (typeof token_from_map === 'object') {\n                curr_rule_tokens.push(token_from_map.concat([value.length]));\n                value = value.substr(tmp[1].length);\n            } else if ((tmp = value.match(/^\\s+/))) {\n                // whitespace is ignored\n                value = value.substr(tmp[0].length);\n            } else if ((tmp = value.match(/^24\\/7/))) {\n                // Reserved keyword.\n                curr_rule_tokens.push([tmp[0], tmp[0], value.length ]);\n                value = value.substr(tmp[0].length);\n            } else if (/^;/.test(value)) {\n                // semicolon terminates rule.\n                // Next token belong to a new rule.\n                all_tokens.push([ curr_rule_tokens, last_rule_fallback_terminated, value.length ]);\n                value = value.substr(1);\n\n                curr_rule_tokens = [];\n                last_rule_fallback_terminated = false;\n            } else if (/^[:.]/.test(value)) {\n                // Time separator (timesep).\n                if (value[0] === '.' && !done_with_warnings) {\n                    parsing_warnings.push([ -1, value.length - 1, t('hour min separator')]);\n                }\n                curr_rule_tokens.push([ ':', 'timesep', value.length ]);\n                value = value.substr(1);\n            } else if ((tmp = value.match(/^(?:PH|SH)/i))) {\n                // special day name (holidays)\n                curr_rule_tokens.push([tmp[0].toUpperCase(), 'holiday', value.length ]);\n                value = value.substr(2);\n            } else if ((tmp = value.match(/^[°\\u2070-\\u209F\\u00B2\\u00B3\\u00B9]{1,2}/))) {\n                const unicode_code_point_to_digit = {\n                    176: 0,\n                    0x2070: 0,\n                    185: 1,\n                    178: 2,\n                    179: 3,\n                }\n                const regular_number = tmp[0].split('').map(function (ch) {\n                    const code_point = ch.charCodeAt(0);\n                    if (typeof unicode_code_point_to_digit[code_point] === 'number') {\n                        return unicode_code_point_to_digit[code_point];\n                    } else if (0x2074 <= code_point && code_point <= 0x2079) {\n                        return code_point - 0x2070;\n                    } else if (0x2080 <= code_point && code_point <= 0x2089) {\n                        return code_point - 0x2080;\n                    }\n                }).join('');\n                let ok = '';\n                if (curr_rule_tokens.length > 0 && matchTokens(curr_rule_tokens, curr_rule_tokens.length-1, 'number')) {\n                    ok += ':';\n                }\n                ok += regular_number;\n                if (!done_with_warnings) {\n                    for (let i = 0; i <= tmp[0].length; i++) {\n                        if (value.charCodeAt(i) === 176) {\n                            parsing_warnings.push([ -1, value.length - (1 + i),\n                                    t('rant degree sign used for zero')]);\n                        }\n                    }\n                    parsing_warnings.push([ -1, value.length - tmp[0].length,\n                            t('please use ok for ko', {'ko': tmp[0], 'ok': ok})]);\n                }\n                value = ok + value.substr(tmp[0].length);\n            } else if ((tmp = value.match(/^(&|_|→|–|−|—|ー|=|·|öffnungszeit(?:en)?:?|opening_hours\\s*=|\\?|~|～|：|always (?:open|closed)|24x7|24 hours 7 days a week|24 hours|7 ?days(?:(?: a |\\/)week)?|7j?\\/7|all days?|every day|(?:bis|till?|-|–)? ?(?:open ?end|late)|(?:(?:one )?day (?:before|after) )?(?:school|public) holidays?|days?\\b|до|рм|ам|jours fériés|on work days?|sonntags?|(?:nur |an )?sonn-?(?:(?: und |\\/)feiertag(?:s|en?)?)?|(?:an )?feiertag(?:s|en?)?|(?:nach|on|by) (?:appointments?|vereinbarung|absprache)|p\\.m\\.|a\\.m\\.|[_a-zäößàáéøčěíúýřПнВсо]+\\b|à|á|mo|tu|we|th|fr|sa|su|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)(\\.?)/i))) {\n                /* Handle all remaining words and specific other characters with error tolerance.\n                 *\n                 * à|á: Word boundary does not work with Unicode chars: 'test à test'.match(/\\bà\\b/i)\n                 * https://stackoverflow.com/questions/10590098/javascript-regexp-word-boundaries-unicode-characters\n                 * Order in the regular expression capturing group is important in some cases.\n                 *\n                 * mo|tu|we|th|fr|sa|su|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec: Prefer defended keywords\n                 * if used in cases like 'mo12:00-14:00' (when keyword is followed by number).\n                 */\n                let correct_val = returnCorrectWordOrToken(tmp[1].toLowerCase(), value.length);\n                // console.log('Error tolerance for string \"' + tmp[1] + '\" returned \"' + correct_val + '\".');\n                if (typeof correct_val === 'object') {\n                    curr_rule_tokens.push([ correct_val[0], correct_val[1], value.length ]);\n                    value = value.substr(tmp[0].length);\n                } else if (typeof correct_val === 'string') {\n                    if (correct_val === 'am' || correct_val === 'pm') {\n                        let hours_token_at = curr_rule_tokens.length - 1;\n                        let hours_token;\n                        if (hours_token_at >= 0) {\n                            if (hours_token_at -2 >= 0 &&\n                                    matchTokens(\n                                        curr_rule_tokens, hours_token_at - 2,\n                                        'number', 'timesep', 'number'\n                                    )\n                            ) {\n                                hours_token_at -= 2;\n                                hours_token = curr_rule_tokens[hours_token_at];\n                            } else if (matchTokens(curr_rule_tokens, hours_token_at, 'number')) {\n                                hours_token = curr_rule_tokens[hours_token_at];\n                            }\n\n                            if (typeof hours_token === 'object') {\n                                if (correct_val === 'pm' && hours_token[0] < 12) {\n                                    hours_token[0] += 12;\n                                }\n                                if (correct_val === 'am' && hours_token[0] === 12) {\n                                    hours_token[0] = 0;\n                                }\n                                curr_rule_tokens[hours_token_at] = hours_token;\n                            }\n                        }\n                        correct_val = '';\n                    }\n                    const correct_tokens = tokenize(correct_val)[0];\n                    if (correct_tokens[1] === true) { // last_rule_fallback_terminated\n                        throw formatLibraryBugMessage();\n                    }\n                    for (let i = 0; i < correct_tokens[0].length; i++) {\n                        curr_rule_tokens.push([correct_tokens[0][i][0], correct_tokens[0][i][1], value.length]);\n                        // value.length - tmp[0].length does not have the desired effect for all test cases.\n                    }\n\n                    value = value.substr(tmp[0].length);\n                    // value = correct_val + value.substr(tmp[0].length);\n                    // Does not work because it would generate the wrong length for formatWarnErrorMessage.\n                } else {\n                    // No correction available. Insert as single character token and let the parser handle the error.\n                    curr_rule_tokens.push([value[0].toLowerCase(), value[0].toLowerCase(), value.length - 1 ]);\n                    value = value.substr(1);\n                }\n                if (typeof tmp[2] === 'string' && tmp[2] !== '' && !done_with_warnings) {\n                    parsing_warnings.push([ -1, value.length, t('omit ko', {'ko': tmp[2]})]);\n                }\n            } else if ((tmp = value.match(/^(\\d+)(?:([.])([^\\d]))?/))) {\n                // number\n                if (Number(tmp[1]) > 1900) { // Assumed to be a year number.\n                    curr_rule_tokens.push([Number(tmp[1]), 'year', value.length ]);\n                    if (Number(tmp[1]) >= 2100) // Probably an error\n                        parsing_warnings.push([ -1, value.length - 1,\n                                t('interpreted as year', {number:  Number(tmp[1])})\n                        ]);\n                } else {\n                    curr_rule_tokens.push([Number(tmp[1]), 'number', value.length ]);\n                }\n\n                value = value.substr(tmp[1].length + (typeof tmp[2] === 'string' ? tmp[2].length : 0));\n                if (typeof tmp[2] === 'string' && tmp[2] !== '' && !done_with_warnings) {\n                    parsing_warnings.push([ -1, value.length, t('omit ko', {'ko': tmp[2]})]);\n                }\n            } else if (/^\\|\\|/.test(value)) {\n                // || terminates rule.\n                // Next token belong to a fallback rule.\n                if (curr_rule_tokens.length === 0) {\n                    throw formatWarnErrorMessage(-1, value.length - 2, t('rule before fallback empty'));\n                }\n\n                all_tokens.push([ curr_rule_tokens, last_rule_fallback_terminated, value.length ]);\n                curr_rule_tokens = [];\n                // curr_rule_tokens = [ [ '||', 'rule separator', value.length  ] ];\n                // FIXME: Use this. Unknown bug needs to be solved in the process.\n                value = value.substr(2);\n\n                last_rule_fallback_terminated = true;\n            } else if ((tmp = value.match(/^\"([^\"]+)\"/))) {\n                // Comment following the specification.\n                // Any character is allowed inside the comment except \" itself.\n                curr_rule_tokens.push([tmp[1], 'comment', value.length ]);\n                value = value.substr(tmp[0].length);\n            } else if ((tmp = value.match(/^([\"'„“‚‘’«「『])([^\"'“”‘’»」』;|]*)([\"'”“‘’»」』])/))) {\n                // Comments with error tolerance.\n                // The comments still have to be somewhat correct meaning\n                // the start and end quote signs used have to be\n                // appropriate. So “testing„ will not match as it is not a\n                // quote but rather something unknown which the user should\n                // fix first.\n                // console.log('Matched: ' + JSON.stringify(tmp));\n                for (let pos = 1; pos <= 3; pos += 2) {\n                    // console.log('Pos: ' + pos + ', substring: ' + tmp[pos]);\n                    const correct_val = returnCorrectWordOrToken(tmp[pos],\n                        value.length - (pos === 3 ? tmp[1].length + tmp[2].length : 0)\n                    );\n                    if (typeof correct_val !== 'string' && tmp[pos] !== '\"') {\n                        throw formatLibraryBugMessage(\n                            'A character for error tolerance was allowed in the regular expression'\n                            + ' but is not covered by word_error_correction'\n                            + ' which is needed to format a proper message for the user.'\n                        );\n                    }\n                }\n                curr_rule_tokens.push([tmp[2], 'comment', value.length ]);\n                value = value.substr(tmp[0].length);\n            } else if (/^(?:␣|\\s)/.test(value)) {\n                // Using \"␣\" as space is not expected to be a normal\n                // mistake. Just ignore it to make using taginfo easier.\n                value = value.substr(1);\n            } else {\n                // other single-character tokens\n                curr_rule_tokens.push([value[0].toLowerCase(), value[0].toLowerCase(), value.length ]);\n                value = value.substr(1);\n            }\n        }\n\n        all_tokens.push([ curr_rule_tokens, last_rule_fallback_terminated ]);\n\n        return all_tokens;\n    }\n    /* }}} */\n\n    /* error correction/tolerance function {{{\n     * Go through word_error_correction hash and get correct value back.\n     *\n     * :param word: Wrong word or character.\n     * :param value_length: Current value_length (used for warnings).\n     * :returns:\n     *        * (valid) opening_hours sub string.\n     *        * object with [ internal_value, token_name ] if value is correct.\n     *        * undefined if word could not be found (and thus is not corrected).\n     */\n    function returnCorrectWordOrToken(word, value_length) {\n        let correctWordOrToken;\n        const token_from_map = string_to_token_map[word];\n        if (typeof token_from_map === 'object') {\n            return token_from_map;\n        }\n        Object.keys(word_error_correction).forEach(function (comment) {\n            if (correctWordOrToken) {\n                return;\n            }\n            Object.keys(word_error_correction[comment]).forEach(function (old_val) {\n                if (correctWordOrToken) {\n                    return;\n                }\n                if (new RegExp('^' + old_val + '$').test(word)) {\n                    const val = word_error_correction[comment][old_val];\n                    // Replace wrong words or characters with correct ones.\n                    // This will return a string which is then being tokenized.\n                    if (!done_with_warnings) {\n                        parsing_warnings.push([\n                            -1,\n                            value_length - word.length,\n                            t(comment, {'ko': word, 'ok': val}),\n                        ]);\n                    }\n                    correctWordOrToken = val;\n                }\n            });\n        });\n        return correctWordOrToken;\n    }\n    /* }}} */\n\n    /* return warnings as list {{{\n     *\n     * :param it: Iterator object if available (optional).\n     * :returns: Warnings as list with one warning per element.\n     */\n    function getWarnings(it) {\n        if (warnings_severity < 4) {\n            return [];\n        }\n\n        if (!done_with_warnings && typeof it === 'object') {\n            /* getWarnings was called in a state without critical errors.\n             * We can do extended tests.\n             */\n\n            /* Place all tests in this function if an additional (high\n             * level) test is added and this does not require to rewrite\n             * big parts of (sub) selector parsers only to get the\n             * position. If that is the case, then rather place the test\n             * code in the (sub) selector parser function directly.\n             */\n\n            const wide_range_selector_order = [ 'year', 'month', 'week', 'holiday' ];\n            const small_range_selector_order = [ 'weekday', 'time', '24/7', 'state', 'comment'];\n\n            // How many times was a selector_type used per rule? {{{\n            const used_selectors = [];\n            const used_selectors_types_array = [];\n            const has_token = {};\n\n            for (let nrule = 0; nrule < new_tokens.length; nrule++) {\n                if (new_tokens[nrule][0].length === 0) continue;\n                // Rule does contain nothing useful e.g. second rule of '10:00-12:00;' (empty) which needs to be handled.\n\n                let selector_start_end_type = [ 0, 0, undefined ];\n                // console.log(new_tokens[nrule][0]);\n\n                used_selectors[nrule] = {};\n                used_selectors_types_array[nrule] = [];\n\n                do {\n                    selector_start_end_type = getSelectorRange(new_tokens[nrule][0], selector_start_end_type[1]);\n                    // console.log(selector_start_end_type, new_tokens[nrule][0].length);\n\n                    for (let token_pos = 0; token_pos <= selector_start_end_type[1]; token_pos++) {\n                        if (typeof new_tokens[nrule][0][token_pos] === 'object' && new_tokens[nrule][0][token_pos][0] === 'PH') {\n                            has_token['PH'] = true;\n                        }\n                    }\n\n                    if (selector_start_end_type[0] === selector_start_end_type[1] &&\n                        new_tokens[nrule][0][selector_start_end_type[0]][0] === '24/7'\n                        ) {\n                            has_token['24/7'] = true;\n                    }\n\n                    if (typeof used_selectors[nrule][selector_start_end_type[2]] !== 'object') {\n                        used_selectors[nrule][selector_start_end_type[2]] = [ selector_start_end_type[1] ];\n                    } else {\n                        used_selectors[nrule][selector_start_end_type[2]].push(selector_start_end_type[1]);\n                    }\n                    used_selectors_types_array[nrule].push(selector_start_end_type[2]);\n\n                    selector_start_end_type[1]++;\n                } while (selector_start_end_type[1] < new_tokens[nrule][0].length);\n            }\n            // console.log('used_selectors: ' + JSON.stringify(used_selectors, null, '    '));\n            // console.log('used_selectors_types_array: ' + JSON.stringify(used_selectors_types_array, null, '    '));\n            /* }}} */\n\n            for (let nrule = 0; nrule < used_selectors.length; nrule++) {\n\n                /* Check if more than one not connected selector of the same type is used in one rule {{{ */\n                Object.keys(used_selectors[nrule]).forEach(function (selector_type) {\n                    // console.log(selector_type + ' use at: ' + used_selectors[nrule][selector_type].length);\n                    if (used_selectors[nrule][selector_type].length > 1) {\n                        parsing_warnings.push([nrule, used_selectors[nrule][selector_type][used_selectors[nrule][selector_type].length - 1],\n                            t('use multi', {\n                                'count': used_selectors[nrule][selector_type].length,\n                                'part2': (\n                                    /^(?:comment|state)/.test(selector_type) ?\n                                        t('selector multi 2a', {'what': (selector_type === 'state' ? t('selector state'): t('comments'))})\n                                        :\n                                        t('selector multi 2b', {'what': t(selector_type + (/^(?:month|weekday)$/.test(selector_type) ? 's' : ' ranges'))})\n                                )\n                            })]\n                        );\n                        done_with_selector_reordering = true; // Correcting the selector order makes no sense if this kind of issue exists.\n                    }\n                });\n                /* }}} */\n                /* Check if change default state rule is not the first rule {{{ */\n                if (   typeof used_selectors[nrule].state === 'object'\n                    && Object.keys(used_selectors[nrule]).length === 1\n                ) {\n                    if (nrule !== 0) {\n                        parsing_warnings.push([nrule, new_tokens[nrule][0].length - 1, t('default state')]);\n                    }\n                /* }}} */\n                /* Check if a rule (with state open) has no time selector {{{ */\n                } else if (typeof used_selectors[nrule].time === 'undefined') {\n                    if (    (       typeof used_selectors[nrule].state === 'object'\n                                && new_tokens[nrule][0][used_selectors[nrule].state[0]][0] === 'open'\n                                && typeof used_selectors[nrule].comment === 'undefined'\n                            ) || ( typeof used_selectors[nrule].comment === 'undefined'\n                                && typeof used_selectors[nrule].state === 'undefined'\n                            ) &&\n                            typeof used_selectors[nrule]['24/7'] === 'undefined'\n                    ) {\n\n                        parsing_warnings.push([nrule, new_tokens[nrule][0].length - 1, t('vague')]);\n                    }\n                }\n                /* }}} */\n                /* Check if empty comment was given {{{ */\n                if (typeof used_selectors[nrule].comment === 'object'\n                    && new_tokens[nrule][0][used_selectors[nrule].comment[0]][0].length === 0\n                ) {\n\n                    parsing_warnings.push([nrule, used_selectors[nrule].comment[0], t('empty comment')]);\n                }\n                /* }}} */\n                /* Check for valid use of <separator_for_readability> {{{ */\n                for (let i = 0; i < used_selectors_types_array[nrule].length - 1; i++) {\n                    const selector_type = used_selectors_types_array[nrule][i];\n                    const next_selector_type = used_selectors_types_array[nrule][i+1];\n                    if (   (   wide_range_selector_order.indexOf(selector_type)       !== -1\n                            && wide_range_selector_order.indexOf(next_selector_type)  !== -1\n                        ) || ( small_range_selector_order.indexOf(selector_type)      !== -1\n                            && small_range_selector_order.indexOf(next_selector_type) !== -1)\n                        ) {\n\n                        if (new_tokens[nrule][0][used_selectors[nrule][selector_type][0]][0] === ':') {\n                            parsing_warnings.push([nrule, used_selectors[nrule][selector_type][0],\n                                t('separator_for_readability')\n                            ]);\n                        }\n                    }\n                }\n                /* }}} */\n                /* Check for missing use of <additional_rule_separator> for time wrapping midnight {{{ */\n                if (typeof rule_infos[nrule] === 'object'\n                        && typeof rule_infos[nrule]['time_wraps_over_midnight'] === 'boolean'\n                        && rule_infos[nrule]['time_wraps_over_midnight'] === true\n                        && typeof used_selectors[nrule+1] === 'object'\n                        && typeof used_selectors[nrule+1]['rule separator'] === 'undefined' // Not an additional rule\n                        && new_tokens[nrule+1][1] === false // Not a fallback rule\n                        ) {\n\n                    const rules_too_complex = [ nrule, nrule+1 ].map(function (nrule){\n                        for (let i = 0; i < wide_range_selector_order.length - 1; i++) {\n                            if (typeof used_selectors[nrule][wide_range_selector_order[i]] === 'object') {\n                                return true;\n                            }\n                        }\n                        return false;\n                    });\n                    const rules_too_complex_count = rules_too_complex.filter(function (el){ return el; }).length;\n                    let next_rule_selects_next_day = false;\n                    if (\n                            typeof rule_infos[nrule] === 'object'\n                            && typeof rule_infos[nrule] === 'object'\n                            && typeof rule_infos[nrule]['week_days'] === 'object'\n                            && typeof rule_infos[nrule+1] === 'object'\n                            && typeof rule_infos[nrule+1]['week_days'] === 'object'\n                            ) {\n                        for (let i = 0; i < rule_infos[nrule]['week_days'].length; i++) {\n                            const week_day = rule_infos[nrule]['week_days'][i];\n                                // console.log(rule_infos[nrule+1]['week_days']);\n                                // console.log(week_day);\n                            if (rule_infos[nrule+1]['week_days'].indexOf(week_day === 6 ? 0 : week_day+1) !== -1) {\n                                next_rule_selects_next_day = true;\n                                break;\n                            }\n                        }\n                    } else {\n                        next_rule_selects_next_day = true;\n                    }\n                    // console.log(rule_infos);\n                    // console.log(next_rule_selects_next_day);\n                    const additional_rule_separator_enabled = (optional_conf_parm||{}).additional_rule_separator !== false;\n                    if (rules_too_complex_count < 2 && next_rule_selects_next_day && additional_rule_separator_enabled) {\n                        parsing_warnings.push([nrule+1, new_tokens[nrule+1][0].length - 1,\n                            t('additional_rule_separator not used after time wrapping midnight'),\n                            new_tokens\n                        ]);\n                    }\n                }\n                /* }}} */\n                /* Check if rule with closed|off modifier is additional {{{ */\n                if (typeof new_tokens[nrule][0][0] === 'object'\n                        && new_tokens[nrule][0][0][0] === ','\n                        && new_tokens[nrule][0][0][1] === 'rule separator'\n                        && typeof used_selectors[nrule].state === 'object'\n                        && (\n                               new_tokens[nrule][0][used_selectors[nrule].state[0]][0] === 'closed'\n                            || new_tokens[nrule][0][used_selectors[nrule].state[0]][0] === 'off'\n                           )\n                ) {\n\n                    parsing_warnings.push([nrule, new_tokens[nrule][0].length - 1,\n                        t('additional rule which evaluates to closed'),\n                        new_tokens\n                    ]);\n                }\n                /* }}} */\n\n            }\n\n            /* Check if 24/7 is used and it does not mean 24/7 because there are other rules {{{ */\n            const has_advanced = it.advance();\n\n            if (has_advanced === true && has_token['24/7'] && !done_with_warnings) {\n                parsing_warnings.push([ -1, 0,\n                    // Probably because of: \"24/7; 12:00-14:00 open\", \". Needs extra testing.\n                    t('strange 24/7')\n                ]);\n            }\n            /* }}} */\n\n            /* Check for missing PH. {{{ */\n            if (    warnings_severity >= 5\n                && !has_token['PH']\n                && !has_token['24/7']\n                && !done_with_warnings\n                && (\n                        (\n                            typeof oh_key === 'string'\n                            && osm_tag_defaults[oh_regex_key]['warn_for_PH_missing']\n                        )\n                        || (typeof oh_key !== 'string')\n                   )\n                ) {\n\n                const keys_with_warn_for_PH_missing = [];\n                Object.keys(osm_tag_defaults).forEach(function (key) {\n                    if (osm_tag_defaults[key]['warn_for_PH_missing']) {\n                        keys_with_warn_for_PH_missing.push(key);\n                    }\n                });\n                parsing_warnings.push([ -1, 0,\n                    t('public holiday', { 'part2': (typeof oh_key !== 'string'\n                        ? t('public holiday part2', {'keys': keys_with_warn_for_PH_missing.join(', ')}) : '')})\n                        // + '(see README how to provide it)' // UI of the evaluation tool does not allow to provide it (currently).\n                ]);\n            }\n            /* }}} */\n\n            /* Check if value consists of multiple rules each only using a time selector {{{ */\n            if (used_selectors_types_array.length > 1\n                    &&  used_selectors_types_array.filter(function (el){\n                            return el.length === 1 && el[0] === 'time';\n                        }).length === used_selectors_types_array.length\n                    ) {\n                parsing_warnings.push([ -1, 0,\n                    t('combine rules', { 'ok': ',' }),\n                ]);\n            }\n            /* }}} */\n\n            prettifyValue();\n        }\n        done_with_warnings = true;\n\n        const warnings = [];\n        // FIXME: Sort based on parsing_warnings[1], tricky …\n        for (let i = 0; i < parsing_warnings.length; i++) {\n            warnings.push( formatWarnErrorMessage(parsing_warnings[i][0], parsing_warnings[i][1], parsing_warnings[i][2], parsing_warnings[i][3]) );\n        }\n        return warnings;\n    }\n\n    /* Helpers for getWarnings {{{ */\n\n    /* Check if token is the begin of a selector and why. {{{\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position where to start.\n     * :returns:\n     *        * false if the current token is not the begin of a selector.\n     *        * Position in token array from where the decision was made that\n     *          the token is the start of a selector.\n     */\n    function tokenIsTheBeginOfSelector(tokens, at) {\n        if (typeof tokens[at][3] === 'string') {\n            return 3;\n        } else if (tokens[at][1] === 'comment'\n                || tokens[at][1] === 'state'\n                || tokens[at][1] === '24/7'\n                || tokens[at][1] === 'rule separator'\n            ){\n\n            return 1;\n        } else {\n            return false;\n        }\n    }\n    /* }}} */\n\n    /* Get start and end position of a selector. {{{\n     * For example this value 'Mo-We,Fr' will return the position of the\n     * token lexeme 'Mo' and 'Fr' e.g. there indexes [ 0, 4 ] in the\n     * selector array of tokens.\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position where to start.\n     * :returns: Array:\n     *            0. Index of first token in selector array of tokens.\n     *            1. Index of last token in selector array of tokens.\n     *            2. Selector type.\n     */\n    function getSelectorRange(tokens, at) {\n        let selector_start = at,\n            selector_end,\n            pos_in_token_array;\n\n        for (; selector_start >= 0; selector_start--) {\n            pos_in_token_array = tokenIsTheBeginOfSelector(tokens, selector_start);\n            if (pos_in_token_array) {\n                break;\n            }\n        }\n        selector_end = selector_start;\n\n        if (pos_in_token_array === 1) {\n            // Selector consists of a single token.\n\n            // Include tailing colon.\n            if (selector_end + 1 < tokens.length && tokens[selector_end + 1][0] === ':')\n                selector_end++;\n\n            return [ selector_start, selector_end, tokens[selector_start][pos_in_token_array] ];\n        }\n\n        for (selector_end++; selector_end < tokens.length ; selector_end++) {\n            if (tokenIsTheBeginOfSelector(tokens, selector_end))\n                return [ selector_start, selector_end - 1, tokens[selector_start][pos_in_token_array] ];\n        }\n\n        return [ selector_start, selector_end - 1, tokens[selector_start][pos_in_token_array] ];\n    }\n    /* }}} */\n    /* }}} */\n    /* }}} */\n\n    /* Prettify raw value from user. {{{\n     * The value is generated by putting the tokens back together to a string.\n     *\n     * :param argument_hash: Hash which can contain:\n     *        'conf': Configuration hash.\n     *        'get_internals: If true export internal data structures.\n     *        'rule_index: Only prettify the rule with this index.\n     * :returns: Prettified value string or object if get_internals is true.\n     */\n    function prettifyValue(argument_hash) {\n        let user_conf = {};\n        let get_internals = false;\n        let rule_index;\n\n        prettified_value = '';\n        const prettified_value_array = [];\n\n        if (typeof argument_hash === 'object') {\n            if (typeof argument_hash.conf === 'object') {\n                user_conf = argument_hash.conf;\n            }\n\n            if (typeof argument_hash.rule_index === 'number') {\n                rule_index = argument_hash.rule_index;\n            }\n\n            if (argument_hash.get_internals === true) {\n                get_internals = true;\n            }\n\n        }\n\n        Object.keys(default_prettify_conf).forEach(function (key) {\n            if (typeof user_conf[key] === 'undefined') {\n                user_conf[key] = default_prettify_conf[key];\n            }\n        });\n\n        // use months, weekdays for locales 'en' and 'all'\n        // otherwise use Date.toLocaleString, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString\n        const _is_en_or_all = (user_conf['locale'] === 'en' || user_conf['locale'] === 'all') && user_conf['date_format'] === 'short';\n        const months_local = _is_en_or_all ? months : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map(function(month) {\n            return new Date(2018, month - 1, 1).toLocaleString(user_conf['locale'], {month: user_conf['date_format']});\n        });\n        const weekdays_local = _is_en_or_all ? weekdays : [1, 2, 3, 4, 5, 6, 7].map(function(weekday) {\n            // 2017-01-01 is Sunday\n            return new Date(2017, 0, weekday).toLocaleString(user_conf['locale'], {weekday: user_conf['date_format']});\n        });\n\n        for (let nrule = 0; nrule < new_tokens.length; nrule++) {\n            if (new_tokens[nrule][0].length === 0) continue;\n            // Rule does contain nothing useful e.g. second rule of '10:00-12:00;' (empty) which needs to be handled.\n\n            if (typeof rule_index === 'number') {\n                if (rule_index !== nrule) continue;\n            } else {\n                if (nrule !== 0)\n                    prettified_value += (\n                        new_tokens[nrule][1]\n                            ? user_conf.rule_sep_string + '|| '\n                            : (\n                                new_tokens[nrule][0][0][1] === 'rule separator'\n                                ? ','\n                                : (\n                                    user_conf.print_semicolon\n                                    ? ';'\n                                    : ''\n                                )\n                            ) +\n                        user_conf.rule_sep_string);\n            }\n\n            let selector_start_end_type = [ 0, 0, undefined ];\n            const prettified_group_value = [];\n            let count = 0;\n            // console.log(new_tokens[nrule][0]);\n\n            do {\n                selector_start_end_type = getSelectorRange(new_tokens[nrule][0], selector_start_end_type[1]);\n                // console.log(selector_start_end_type, new_tokens[nrule][0].length, count);\n\n                if (count > 50) {\n                    throw formatLibraryBugMessage('Infinite loop.');\n                }\n\n                if (selector_start_end_type[2] !== 'rule separator') {\n                    prettified_group_value.push(\n                        [\n                            selector_start_end_type,\n                            prettifySelector(\n                                new_tokens[nrule][0],\n                                selector_start_end_type[0],\n                                selector_start_end_type[1],\n                                selector_start_end_type[2],\n                                user_conf\n                            ),\n                        ]\n                    );\n                }\n\n                selector_start_end_type[1]++;\n                count++;\n                // console.log(selector_start_end_type, new_tokens[nrule][0].length, count);\n            } while (selector_start_end_type[1] < new_tokens[nrule][0].length);\n            // console.log('Prettified value: ' + JSON.stringify(prettified_group_value, null, '    '));\n            const not_sorted_prettified_group_value = prettified_group_value.slice();\n\n            if (!done_with_selector_reordering) {\n                prettified_group_value.sort(\n                    function (a, b) {\n                        const selector_order = [ 'year', 'month', 'week', 'holiday', 'weekday', 'time', '24/7', 'state', 'comment'];\n                        return selector_order.indexOf(a[0][2]) - selector_order.indexOf(b[0][2]);\n                    }\n                );\n            }\n            const old_prettified_value_length = prettified_value.length;\n\n            if (typeof user_conf['locale'] === 'string' && user_conf['locale'] !== 'en') {\n                let translatorFunction;\n                if (i18next.language !== user_conf['locale']) {\n                    translatorFunction = i18next.getFixedT(user_conf['locale']);\n                } else {\n                    translatorFunction = i18next.t;\n                }\n                for (let i = 0; i < prettified_group_value.length; i++) {\n                    const type = prettified_group_value[i][0][2];\n                    if (type === 'weekday') {\n                        weekdays.forEach(function (weekday, key) {\n                            prettified_group_value[i][1] = prettified_group_value[i][1].replace(new RegExp(weekday, 'g'), weekdays_local[key]);\n                        });\n                    } else if (type === 'month') {\n                        months.forEach(function (month, key) {\n                            prettified_group_value[i][1] = prettified_group_value[i][1].replace(new RegExp(month, 'g'), months_local[key]);\n                        });\n                    } else {\n                        const prettifiedValueIsProbablyTranslatable = prettified_group_value[i][1].indexOf(':') === -1;\n                        if (prettifiedValueIsProbablyTranslatable) {\n                            prettified_group_value[i][1] = translatorFunction(['opening_hours:pretty.' + prettified_group_value[i][1], prettified_group_value[i][1]]);\n                        }\n                    }\n                }\n            }\n\n            prettified_value += prettified_group_value.map(function (array) {\n                return array[1];\n            }).join(' ');\n\n            prettified_value_array.push( prettified_group_value );\n\n            if (!done_with_selector_reordering_warnings) {\n                for (let i = 0, l = not_sorted_prettified_group_value.length; i < l; i++) {\n                    if (not_sorted_prettified_group_value[i] !== prettified_group_value[i]) {\n                        // console.log(i + ': ' + prettified_group_value[i][0][2]);\n                        let length = i + old_prettified_value_length; // i: Number of spaces in string.\n                        for (let x = 0; x <= i; x++) {\n                            length += prettified_group_value[x][1].length;\n                            // console.log('Length: ' + length + ' ' + prettified_group_value[x][1]);\n                        }\n                        // console.log(length);\n                        parsing_warnings.push([ prettified_value, length, t('switched', {\n                            'first': prettified_group_value[i][0][2],\n                            'second': not_sorted_prettified_group_value[i][0][2]\n                        })\n                        ]);\n                    }\n                }\n            }\n        }\n\n        done_with_selector_reordering_warnings = true;\n        // console.log(JSON.stringify(prettified_value_array, null, '    '));\n\n        if (get_internals) {\n            return [ prettified_value_array, new_tokens ];\n        } else {\n            return prettified_value;\n        }\n    }\n    /* }}} */\n\n    /* Check selector array of tokens for specific token name pattern. {{{\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position at which the matching should begin.\n     * :param token_name(s): One or many token_name strings which have to match in that order.\n     * :returns: true if token_name(s) match in order false otherwise.\n     */\n    function matchTokens(tokens, at /*, matches... */) {\n        if (at + arguments.length - 2 > tokens.length)\n            return false;\n        for (let i = 0; i < arguments.length - 2; i++) {\n            if (tokens[at + i][1] !== arguments[i + 2]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n    /* }}} */\n\n    /* Generate selector wrapper with time offset {{{\n     *\n     * :param func: Generated selector code function.\n     * :param shirt: Time to shift in milliseconds.\n     * :param token_name(s): One or many token_name strings which have to match in that order.\n     * :returns: See selector code.\n     */\n    function generateDateShifter(func, shift) {\n        return function(date) {\n            const res = func(new Date(date.getTime() + shift));\n\n            if (typeof res[1] === 'undefined')\n                return res;\n            return [ res[0], new Date(res[1].getTime() - shift) ];\n        };\n    }\n    /* }}} */\n\n    /* Top-level parser {{{\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position where to start.\n     * :param rule: Reference to rule object.\n     * :param nrule: Rule number starting with 0.\n     * :returns: See selector code.\n     */\n    function parseGroup(tokens, at, rule, nrule) {\n        let rule_modifier_specified = false;\n\n        // console.log(tokens); // useful for debugging of tokenize\n        let last_selector = [];\n        while (at < tokens.length) {\n            // console.log('Parsing at position', at +':', tokens[at]);\n            if (matchTokens(tokens, at, 'weekday')) {\n                at = parseWeekdayRange(tokens, at, rule, undefined, nrule);\n            } else if (matchTokens(tokens, at, '24/7')) {\n                rule.time.push(function() { return [true]; });\n                // Not needed. If there is no selector it automatically matches everything.\n                // WRONG: This only works if there is no other selector in this selector group ...\n                at++;\n            } else if (matchTokens(tokens, at, 'holiday')) {\n                if (matchTokens(tokens, at+1, ',')) {\n                    at = parseHoliday(tokens, at, rule, true);\n                } else {\n                    at = parseHoliday(tokens, at, rule, false);\n                }\n                week_stable = false;\n            } else if (matchTokens(tokens, at, 'month', 'number')\n                    || matchTokens(tokens, at, 'month', 'weekday')\n                    || matchTokens(tokens, at, 'year', 'month', 'number')\n                    || matchTokens(tokens, at, 'year', 'event')\n                    || matchTokens(tokens, at, 'event')) {\n\n                at = parseMonthdayRange(tokens, at, nrule);\n                week_stable = false;\n            } else if (matchTokens(tokens, at, 'year')) {\n                at = parseYearRange(tokens, at);\n                week_stable = false;\n            } else if (matchTokens(tokens, at, 'month')) {\n                at = parseMonthRange(tokens, at);\n                // week_stable = false; // Decided based on the actual value/tokens.\n            } else if (matchTokens(tokens, at, 'week')) {\n                tokens[at][3] = 'week';\n                at = parseWeekRange(tokens, at);\n\n            } else if (at !== 0 && at !== tokens.length - 1 && tokens[at][0] === ':'\n                && !(typeof last_selector[1] === 'string' && last_selector[1] === 'time')) {\n                /* Ignore colon if they appear somewhere else than as time separator.\n                 * Except the start or end of the value.\n                 * This provides compatibility with the syntax proposed by Netzwolf:\n                 * https://wiki.openstreetmap.org/wiki/Key:opening_hours/specification#separator_for_readability\n                 * Check for valid use of <separator_for_readability> is implemented in function getWarnings().\n                 */\n\n                if (!done_with_warnings && matchTokens(tokens, at-1, 'holiday')) {\n                    parsing_warnings.push([nrule, at, t('no colon after', { 'token': tokens[at-1][1] })]);\n                }\n\n                at++;\n            } else if (matchTokens(tokens, at, 'number', 'timesep')\n                    || matchTokens(tokens, at, 'timevar')\n                    || matchTokens(tokens, at, '(', 'timevar')\n                    || matchTokens(tokens, at, 'number', '-')) {\n\n                at = parseTimeRange(tokens, at, rule, false, nrule);\n                last_selector = [ at, 'time' ];\n\n            } else if (matchTokens(tokens, at, 'state')) {\n\n                if (tokens[at][0] === 'open') {\n                    rule.meaning = true;\n                } else if (tokens[at][0] === 'closed' || tokens[at][0] === 'off') {\n                    rule.meaning = false;\n                } else {\n                    rule.meaning = false;\n                    rule.unknown = true;\n                }\n\n                rule_modifier_specified = true;\n                at++;\n                if (typeof tokens[at] === 'object' && tokens[at][0] === ',') // additional rule\n                    at = [ at + 1 ];\n\n            } else if (matchTokens(tokens, at, 'comment')) {\n                rule.comment = tokens[at][0];\n                if (!rule_modifier_specified) {\n                    // Then it is unknown. Either with unknown explicitly\n                    // specified or just a comment.\n                    rule.meaning = false;\n                    rule.unknown = true;\n                }\n\n                rule_modifier_specified = true;\n                at++;\n                if (typeof tokens[at] === 'object' && tokens[at][0] === ',') { // additional rule\n                    at = [ at + 1 ];\n                }\n            } else if ((at === 0 || at === tokens.length - 1) && matchTokens(tokens, at, 'rule separator')) {\n                at++;\n                // console.log(\"value: \" + nrule);\n                // throw formatLibraryBugMessage('Not implemented yet.');\n            } else {\n                const warnings = getWarnings();\n                throw formatWarnErrorMessage(nrule, at, t('unexpected token', {token: tokens[at][1] })) + (warnings ? (' ' + warnings.join('; ')) : '');\n            }\n\n            if (typeof at === 'object') { // additional rule\n                tokens[at[0] - 1][1] = 'rule separator';\n                break;\n            }\n            if (typeof last_selector[0] === 'number' && last_selector[0] !== at) {\n                last_selector = [];\n            }\n        }\n\n        return at;\n    }\n\n    /* Not used\n    function get_last_token_pos_in_token_group(tokens, at, last_at) {\n        for (at++; at < last_at; at++) {\n            if (typeof tokens[at] === 'object') {\n                if (typeof tokens[at][3] === 'string'\n                        || tokens[at][1] === 'comment'\n                        || tokens[at][1] === 'state'){\n\n                        return at - 1;\n                }\n            }\n        }\n        return last_at;\n    }\n    */\n\n    /* }}} */\n\n    // helper functions for sub parser {{{\n\n    /* For given date, returns date moved to the start of the day with an offset specified in minutes. {{{\n     * For example, if date is 2014-05-19_18:17:12, dateAtDayMinutes would\n     * return 2014-05-19_02:00:00 for minutes=120.\n     *\n     * :param date: Date object.\n     * :param minutes: Minutes used as offset starting from midnight of current day.\n     * :returns: Moved date object.\n     */\n    function dateAtDayMinutes(date, minutes) {\n        return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, minutes);\n    }\n    /* }}} */\n\n    /* For given date, returns date moved to the specific day of week {{{\n     *\n     * :param date: Date object.\n     * :param weekday: Integer number for day of week. Starting with zero (Sunday).\n     * :returns: Moved date object.\n     */\n    function dateAtNextWeekday(date, weekday) {\n        const delta = weekday - date.getDay();\n        return new Date(date.getFullYear(), date.getMonth(), date.getDate() + delta + (delta < 0 ? 7 : 0));\n    }\n    /* }}} */\n\n    /* Numeric list parser (1,2,3-4,-1) {{{\n     * Used in weekday parser above.\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position where to start.\n     * :param func: Function func(from, to, at).\n     * :returns: Position at which the token does not belong to the list any more.\n     */\n    function parseNumRange(tokens, at, func) {\n        for (; at < tokens.length; at++) {\n            if (matchTokens(tokens, at, 'number', '-', 'number')) {\n                // Number range\n                func(tokens[at][0], tokens[at+2][0], at);\n                at += 3;\n            } else if (matchTokens(tokens, at, '-', 'number')) {\n                // Negative number\n                func(-tokens[at+1][0], -tokens[at+1][0], at);\n                at += 2;\n            } else if (matchTokens(tokens, at, 'number')) {\n                // Single number\n                func(tokens[at][0], tokens[at][0], at);\n                at++;\n            } else {\n                throw formatWarnErrorMessage(nrule, at + matchTokens(tokens, at, '-'),\n                    'Unexpected token in number range: ' + tokens[at][1]);\n            }\n\n            if (!matchTokens(tokens, at, ','))\n                break;\n        }\n\n        return at;\n    }\n    /* }}} */\n\n    /* List parser for constrained weekdays in month range {{{\n     * e.g. Su[-1] which selects the last Sunday of the month.\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position where to start.\n     * :returns: Array:\n     *            0. Constrained weekday number.\n     *            1. Position at which the token does not belong to the list any more (after ']' token).\n     */\n    function getConstrainedWeekday(tokens, at) {\n        let number = 0;\n        const endat = parseNumRange(tokens, at, function(from, to, at) {\n\n            // bad number\n            if (from === 0 || from < -5 || from > 5)\n                throw formatWarnErrorMessage(nrule, at,\n                    t('number -5 to 5'));\n\n            if (from === to) {\n                if (number !== 0)\n                    throw formatWarnErrorMessage(nrule, at,\n                        t('one weekday constraint'));\n                number = from;\n            } else {\n                throw formatWarnErrorMessage(nrule, at+2,\n                    t('range constrained weekdays'));\n            }\n        });\n        for (let i = at; i < endat; i++) {\n            tokens[i][4] = 'positive_number';\n        }\n\n        if (!matchTokens(tokens, endat, ']'))\n            throw formatWarnErrorMessage(nrule, endat, t('expected', {symbol: ']'}));\n\n        return [ number, endat + 1 ];\n    }\n    /* }}} */\n\n    // Check if period is ok. Period 0 or 1 don’t make much sense.\n    function checkPeriod(at, period, period_type, parm_string) {\n        if (done_with_warnings)\n            return;\n\n        if (period === 0) {\n            throw formatWarnErrorMessage(nrule, at,\n                t('range zero', { 'type': period_type }));\n        } else if (period === 1) {\n            if (typeof parm_string === 'string' && parm_string === 'no_end_year')\n                parsing_warnings.push([nrule, at, t('period one year+', {'type': period_type})]);\n            else\n                parsing_warnings.push([nrule, at, t('period one', {'type': period_type})]);\n        }\n    }\n\n    /* Get date moved to constrained weekday (and moved for add_days. {{{\n     * E.g. used for 'Aug Su[-1] -1 day'.\n     *\n     * :param year: Year as integer.\n     * :param month: Month as integer starting with zero.\n     * :param weekday: Integer number for day of week. Starting with zero (Sunday).\n     * :param constrained_weekday: Position where to start.\n     * :returns: Date object.\n     */\n    function getDateForConstrainedWeekday(year, month, weekday, constrained_weekday, add_days) {\n        const tmp_date = dateAtNextWeekday(\n            new Date(year, month + (constrained_weekday[0] > 0 ? 0 : 1), 1), weekday);\n\n        tmp_date.setDate(tmp_date.getDate() + (constrained_weekday[0] + (constrained_weekday[0] > 0 ? -1 : 0)) * 7);\n\n        if (typeof add_days === 'object' && add_days[1])\n            tmp_date.setDate(tmp_date.getDate() + add_days[0]);\n\n        return tmp_date;\n    }\n    /* }}} */\n\n    /* Check if date is valid. {{{\n     *\n     * :param month: Month as integer starting with zero.\n     * :param date: Day of month as integer.\n     * :param nrule: Rule number starting with 0.\n     * :param at: Position at which the matching should begin.\n     * :returns: undefined. There is no real return value. This function just throws an exception if something is wrong.\n     */\n    function checkIfDateIsValid(month, day, nrule, at) {\n        // May use this instead. The problem is that this does not give feedback as precise as the code which is used in this function.\n        // let testDate = new Date(year, month, day);\n        // if (testDate.getDate() !== day || testDate.getMonth() !== month || testDate.getFullYear() !== year) {\n        //     console.error('date not valid');\n        // }\n\n        // https://en.wikipedia.org/wiki/Month#Julian_and_Gregorian_calendars\n        if (day < 1 || day > 31) {\n            throw formatWarnErrorMessage(nrule, at, t('month 31', {'month': months[month]}));\n        } else if ((month === 3 || month === 5 || month === 8 || month === 10) && day === 31) {\n            throw formatWarnErrorMessage(nrule, at, t('month 30', {'month': months[month]}));\n        } else if (month === 1 && day === 30) {\n            throw formatWarnErrorMessage(nrule, at, t('month feb', {'month': months[month]}));\n        }\n    }\n    /* }}} */\n    /* }}} */\n\n    /* Time range parser (10:00-12:00,14:00-16:00) {{{\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position where to start.\n     * :param rule: Reference to rule object.\n     * :param extended_open_end: Used for combined time range with open end.\n     * :param nrule: Rule number starting with 0.\n     * extended_open_end: <time> - <time> +\n     *        parameter at is here A (if extended_open_end is true)\n     * :returns: Position at which the token does not belong to the selector anymore.\n     */\n    function parseTimeRange(tokens, at, rule, extended_open_end, nrule) {\n        if (!extended_open_end)\n            tokens[at][3] = 'time';\n\n        for (; at < tokens.length; at++) {\n            const has_time_var_calc = [], has_normal_time = []; // element 0: start time, 1: end time\n                has_normal_time[0]   = matchTokens(tokens, at, 'number', 'timesep', 'number');\n                has_time_var_calc[0] = matchTokens(tokens, at, '(', 'timevar');\n            let minutes_from,\n                minutes_to,\n                has_open_end = false; // default no open end\n            if (has_normal_time[0] || matchTokens(tokens, at, 'timevar') || has_time_var_calc[0]) {\n                // relying on the fact that always *one* of them is true\n\n                let is_point_in_time = false; // default no time range\n                const timevar_add    = [ 0, 0 ];\n                let timevar_string   = [];    // capture timevar string like 'sunrise' to calculate it for the current date.\n                let point_in_time_period;\n\n                // minutes_from\n                if (has_normal_time[0]) {\n                    minutes_from = getMinutesByHoursMinutes(tokens, nrule, at+has_time_var_calc[0]);\n                } else {\n                    timevar_string[0] = tokens[at+has_time_var_calc[0]][0];\n                    minutes_from = word_value_replacement[timevar_string[0]];\n\n                    if (has_time_var_calc[0]) {\n                        timevar_add[0] = parseTimevarCalc(tokens, at);\n                        minutes_from += timevar_add[0];\n                    }\n                }\n\n                const at_end_time = at+(has_normal_time[0] ? 3 : (has_time_var_calc[0] ? 7 : 1))+1; // after '-'\n                if (!matchTokens(tokens, at_end_time - 1, '-')) { // not time range\n                    if (matchTokens(tokens, at_end_time - 1, '+')) {\n                        has_open_end = true;\n                    } else {\n                        if (oh_mode === 0) {\n                            throw formatWarnErrorMessage(nrule,\n                                at+(\n                                    has_normal_time[0] ? (\n                                        typeof tokens[at+3] === 'object' ? 3 : 2\n                                    ) : (\n                                        has_time_var_calc[0] ? 2 : (\n                                                typeof tokens[at+1] === 'object' ? 1 : 0\n                                            )\n                                    )\n                                ),\n                                t('point in time', {\n                                    'calc': (has_time_var_calc[0] ? t('calculation') + ' ' : ''),\n                                    'libraryname': library_name\n                                }));\n                        } else {\n                            minutes_to = minutes_from + 1;\n                            is_point_in_time = true;\n                        }\n                    }\n                }\n\n                // minutes_to\n                if (has_open_end) {\n                    if (extended_open_end === 1) {\n                        minutes_from += minutes_in_day;\n                    }\n                    if (minutes_from >= 22 * 60) {\n\n                        minutes_to = minutes_from +  8 * 60;\n                    } else if (minutes_from >= 17 * 60) {\n                        minutes_to = minutes_from + 10 * 60;\n                    } else {\n                        minutes_to = minutes_in_day;\n                    }\n                } else if (!is_point_in_time) {\n                    has_normal_time[1] = matchTokens(tokens, at_end_time, 'number', 'timesep', 'number');\n                    has_time_var_calc[1]      = matchTokens(tokens, at_end_time, '(', 'timevar');\n                    if (!has_normal_time[1] && !matchTokens(tokens, at_end_time, 'timevar') && !has_time_var_calc[1]) {\n                        throw formatWarnErrorMessage(nrule, at_end_time - (typeof tokens[at_end_time] === 'object' ? 0 : 1),\n                                t('time range continue'));\n                    } else {\n                        if (has_normal_time[1]) {\n                            minutes_to = getMinutesByHoursMinutes(tokens, nrule, at_end_time);\n                        } else {\n                            timevar_string[1] = tokens[at_end_time+has_time_var_calc[1]][0];\n                            minutes_to = word_value_replacement[timevar_string[1]];\n                        }\n\n                        if (has_time_var_calc[1]) {\n                            timevar_add[1] = parseTimevarCalc(tokens, at_end_time);\n                            minutes_to += timevar_add[1];\n                        }\n                    }\n                }\n\n                at = at_end_time + (is_point_in_time ? -1 :\n                        (has_normal_time[1] ? 3 : (has_time_var_calc[1] ? 7 : !has_open_end))\n                    );\n\n                if (matchTokens(tokens, at, '/', 'number')) {\n                    if (matchTokens(tokens, at + 2, 'timesep', 'number')) { // /hours:minutes\n                        point_in_time_period = getMinutesByHoursMinutes(tokens, nrule, at + 1);\n                        at += 4;\n                    } else { // /minutes\n                        point_in_time_period = tokens[at + 1][0];\n                        at += 2;\n                        if (matchTokens(tokens, at, 'timesep'))\n                            throw formatWarnErrorMessage(nrule, at,\n                                t('period continue'));\n                    }\n\n                    // Check at this later state in the if condition to get the correct position.\n                    if (oh_mode === 0) {\n                        throw formatWarnErrorMessage(nrule, at - 1,\n                            t('time range mode', {'libraryname': library_name}));\n                    }\n\n                    is_point_in_time = true;\n                } else if (matchTokens(tokens, at, '+')) {\n                    parseTimeRange(tokens, at_end_time, rule, minutes_to < minutes_from ? 1 : true, nrule);\n                    at++;\n                } else if (oh_mode === 1 && !is_point_in_time) {\n                    throw formatWarnErrorMessage(nrule, at_end_time,\n                        t('point in time mode', {'libraryname': library_name}));\n                }\n\n                if (typeof lat === 'string') { // lon will also be defined (see above)\n                    if (!has_normal_time[0] || !(has_normal_time[1] || has_open_end || is_point_in_time) ) {\n                        week_stable = false;\n                    }\n                } else { // we can not calculate exact times so we use the already applied constants (word_value_replacement).\n                    timevar_string = [];\n                }\n\n                // Normalize minutes into range.\n                if (!extended_open_end && minutes_from >= minutes_in_day) {\n                    throw formatWarnErrorMessage(nrule, at_end_time - 2,\n                        t('outside current day'));\n                }\n                if (minutes_to < minutes_from || ((has_normal_time[0] && has_normal_time[1]) && minutes_from === minutes_to)) {\n                    minutes_to += minutes_in_day;\n                }\n                if (minutes_to > minutes_in_day * 2) {\n                    throw formatWarnErrorMessage(nrule, at_end_time + (has_normal_time[1] ? 4 : (has_time_var_calc[1] ? 7 : 1)) - 2,\n                        t('two midnights'));\n                }\n\n                // This shortcut makes always-open range check faster.\n                if (minutes_from === 0 && minutes_to === minutes_in_day) {\n                    rule.time.push(function() { return [true]; });\n                } else {\n                    if (minutes_to > minutes_in_day) { // has_normal_time[1] must be true\n                        rule.time.push(function(minutes_from, minutes_to, timevar_string, timevar_add, has_open_end, is_point_in_time, point_in_time_period, extended_open_end) { return function(date) {\n                            const ourminutes = date.getHours() * 60 + date.getMinutes();\n\n                            if (timevar_string[0]) {\n                                const date_from = SunCalc.getTimes(date, lat, lon)[timevar_string[0]];\n                                minutes_from  = date_from.getHours() * 60 + date_from.getMinutes() + timevar_add[0];\n                            }\n                            if (timevar_string[1]) {\n                                const date_to = SunCalc.getTimes(date, lat, lon)[timevar_string[1]];\n                                minutes_to  = date_to.getHours() * 60 + date_to.getMinutes() + timevar_add[1];\n                                minutes_to += minutes_in_day;\n                                // Needs to be added because it was added by\n                                // normal times: if (minutes_to < minutes_from)\n                                // above the selector construction.\n                            } else if (is_point_in_time && typeof point_in_time_period !== 'number') {\n                                minutes_to = minutes_from + 1;\n                            }\n\n                            if (typeof point_in_time_period === 'number') {\n                                if (ourminutes < minutes_from) {\n                                    return [false, dateAtDayMinutes(date, minutes_from)];\n                                } else if (ourminutes <= minutes_to) {\n                                    for (let cur_min = minutes_from; ourminutes + point_in_time_period >= cur_min; cur_min += point_in_time_period) {\n                                        if (cur_min === ourminutes) {\n                                            return [true, dateAtDayMinutes(date, ourminutes + 1)];\n                                        } else if (ourminutes < cur_min) {\n                                            return [false, dateAtDayMinutes(date, cur_min)];\n                                        }\n                                    }\n                                }\n                                return [false, dateAtDayMinutes(date, minutes_in_day)];\n                            } else {\n                                if (ourminutes < minutes_from)\n                                    return [false, dateAtDayMinutes(date, minutes_from)];\n                                else\n                                    return [true, dateAtDayMinutes(date, minutes_to), has_open_end, extended_open_end];\n                            }\n                        }}(minutes_from, minutes_to, timevar_string, timevar_add, has_open_end, is_point_in_time, point_in_time_period, extended_open_end));\n\n                        if (minutes_to - minutes_in_day > 0) {\n                            if (typeof rule_infos[nrule] === 'undefined') {\n                                rule_infos[nrule] = {};\n                            }\n                            rule_infos[nrule]['time_wraps_over_midnight'] = true;\n                            rule.wraptime.push(function(minutes_to, timevar_string, timevar_add, has_open_end, point_in_time_period, extended_open_end) { return function(date) {\n                                const ourminutes = date.getHours() * 60 + date.getMinutes();\n\n                                if (timevar_string[1]) {\n                                    const date_to = SunCalc.getTimes(date, lat, lon)[timevar_string[1]];\n                                    minutes_to  = date_to.getHours() * 60 + date_to.getMinutes() + timevar_add[1];\n                                    // minutes_in_day does not need to be added.\n                                    // For normal times in it was added in: if (minutes_to < // minutes_from)\n                                    // above the selector construction and\n                                    // subtracted in the selector construction call\n                                    // which returns the selector function.\n                                }\n\n                                if (typeof point_in_time_period === 'number') {\n                                    if (ourminutes <= minutes_to) {\n                                        for (let cur_min = 0; ourminutes + point_in_time_period >= cur_min; cur_min += point_in_time_period) {\n                                            if (cur_min === ourminutes) {\n                                                return [true, dateAtDayMinutes(date, ourminutes + 1)];\n                                            } else if (ourminutes < cur_min) {\n                                                return [false, dateAtDayMinutes(date, cur_min)];\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (ourminutes < minutes_to)\n                                        return [true, dateAtDayMinutes(date, minutes_to), has_open_end, extended_open_end];\n                                }\n                                return [false, undefined];\n                            }}(minutes_to - minutes_in_day, timevar_string, timevar_add, has_open_end, point_in_time_period, extended_open_end));\n                        }\n                    } else {\n                        rule.time.push(function(minutes_from, minutes_to, timevar_string, timevar_add, has_open_end, is_point_in_time, point_in_time_period) { return function(date) {\n                            const ourminutes = date.getHours() * 60 + date.getMinutes();\n\n                            if (timevar_string[0]) {\n                                const date_from = SunCalc.getTimes(date, lat, lon)[timevar_string[0]];\n                                minutes_from  = date_from.getHours() * 60 + date_from.getMinutes() + timevar_add[0];\n                            }\n                            if (timevar_string[1]) {\n                                const date_to = SunCalc.getTimes(date, lat, lon)[timevar_string[1]];\n                                minutes_to  = date_to.getHours() * 60 + date_to.getMinutes() + timevar_add[1];\n                            } else if (is_point_in_time && typeof point_in_time_period !== 'number') {\n                                minutes_to = minutes_from + 1;\n                            }\n\n                            if (typeof point_in_time_period === 'number') {\n                                if (ourminutes < minutes_from) {\n                                    return [false, dateAtDayMinutes(date, minutes_from)];\n                                } else if (ourminutes <= minutes_to) {\n                                    for (let cur_min = minutes_from; ourminutes + point_in_time_period >= cur_min; cur_min += point_in_time_period) {\n                                        if (cur_min === ourminutes) {\n                                            return [true, dateAtDayMinutes(date, ourminutes + 1)];\n                                        } else if (ourminutes < cur_min) {\n                                            return [false, dateAtDayMinutes(date, cur_min)];\n                                        }\n                                    }\n                                }\n                                return [false, dateAtDayMinutes(date, minutes_in_day)];\n                            } else {\n                                if (ourminutes < minutes_from)\n                                    return [false, dateAtDayMinutes(date, minutes_from)];\n                                else if (ourminutes < minutes_to)\n                                    return [true, dateAtDayMinutes(date, minutes_to), has_open_end];\n                                else\n                                    return [false, dateAtDayMinutes(date, minutes_from + minutes_in_day)];\n                            }\n                        }}(minutes_from, minutes_to, timevar_string, timevar_add, has_open_end, is_point_in_time, point_in_time_period));\n                    }\n                }\n\n            } else if (matchTokens(tokens, at, 'number', '-', 'number')) { // \"Mo 09-18\" (Please don’t use this) -> \"Mo 09:00-18:00\".\n                minutes_from = tokens[at][0]   * 60;\n                minutes_to   = tokens[at+2][0] * 60;\n                if (!done_with_warnings) {\n                    parsing_warnings.push([nrule, at + 2, t('without minutes', {\n                        'syntax': (tokens[at][0]   < 10 ? '0' : '') + tokens[at][0]   + ':00-'\n                                + (tokens[at+2][0] < 10 ? '0' : '') + tokens[at+2][0] + ':00'\n                    })]);\n                }\n\n                if (minutes_from >= minutes_in_day)\n                    throw formatWarnErrorMessage(nrule, at, t('outside day'));\n                if (minutes_to < minutes_from)\n                    minutes_to += minutes_in_day;\n                if (minutes_to > minutes_in_day * 2)\n                    throw formatWarnErrorMessage(nrule, at + 2, t('two midnights'));\n\n                if (minutes_to > minutes_in_day) {\n                    rule.time.push(function(minutes_from, minutes_to) { return function(date) {\n                        const ourminutes = date.getHours() * 60 + date.getMinutes();\n\n                        if (ourminutes < minutes_from)\n                            return [false, dateAtDayMinutes(date, minutes_from)];\n                        else\n                            return [true, dateAtDayMinutes(date, minutes_to)];\n                    }}(minutes_from, minutes_to));\n\n                    if (minutes_to - minutes_in_day > 0) {\n                        if (typeof rule_infos[nrule] === 'undefined') {\n                            rule_infos[nrule] = {};\n                        }\n                        rule_infos[nrule]['time_wraps_over_midnight'] = true;\n                        rule.wraptime.push(function(minutes_to) { return function(date) {\n                            const ourminutes = date.getHours() * 60 + date.getMinutes();\n\n                            if (ourminutes < minutes_to) {\n                                return [true, dateAtDayMinutes(date, minutes_to)];\n                            } else {\n                                return [false, undefined];\n                            }\n                        }}(minutes_to - minutes_in_day));\n                    }\n                } else {\n                    rule.time.push(function(minutes_from, minutes_to) { return function(date) {\n                        const ourminutes = date.getHours() * 60 + date.getMinutes();\n\n                        if (ourminutes < minutes_from)\n                            return [false, dateAtDayMinutes(date, minutes_from)];\n                        else if (ourminutes < minutes_to)\n                            return [true, dateAtDayMinutes(date, minutes_to), has_open_end];\n                        else\n                            return [false, dateAtDayMinutes(date, minutes_from + minutes_in_day)];\n                    }}(minutes_from, minutes_to));\n                }\n\n                at += 3;\n            } else { // additional rule\n                if (matchTokens(tokens, at, '('))\n                    throw formatWarnErrorMessage(nrule, at, 'Missing variable time (e.g. sunrise) after: \"' + tokens[at][1] + '\"');\n                if (matchTokens(tokens, at, 'number', 'timesep'))\n                    throw formatWarnErrorMessage(nrule, at+1, 'Missing minutes in time range after: \"' + tokens[at+1][1] + '\"');\n                if (matchTokens(tokens, at, 'number'))\n                    throw formatWarnErrorMessage(nrule, at + (typeof tokens[at+1] === 'object' ? 1 : 0),\n                            'Missing time separator in time range after: \"' + tokens[at][1] + '\"');\n                return [ at ];\n            }\n\n            if (!matchTokens(tokens, at, ',')) {\n                break;\n            }\n\n            if (typeof tokens[at+1] === 'undefined' && !done_with_warnings) {\n                parsing_warnings.push([nrule, at, t('value ends with token', { 'token': tokens[at][1] }) ]);\n            }\n        }\n\n        return at;\n    }\n    /* }}} */\n\n    /* Helpers for time range parser {{{ */\n\n    /* Get time in minutes from <hour>:<minute> (tokens). {{{\n     * Only used if throwing an error is wanted.\n     *\n     * :param tokens: List of token objects.\n     * :param nrule: Rule number starting with 0.\n     * :param at: Position at which the time begins.\n     * :returns: Time in minutes.\n     */\n    function getMinutesByHoursMinutes(tokens, nrule, at) {\n        if (tokens[at+2][0] > 59)\n            throw formatWarnErrorMessage(nrule, at+2,\n                    'Minutes are greater than 59.');\n        return tokens[at][0] * 60 + tokens[at+2][0];\n    }\n    /* }}} */\n\n    /* Get time in minutes from \"(sunrise-01:30)\" {{{\n     * Extract the added or subtracted time from \"(sunrise-01:30)\"\n     * returns time in minutes e.g. -90.\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position where the specification for the point in time could be.\n     * :returns: Time in minutes on suggest, throws an exception otherwise.\n    */\n    function parseTimevarCalc(tokens, at) {\n        let error;\n        if (matchTokens(tokens, at+2, '+') || matchTokens(tokens, at+2, '-')) {\n            if (matchTokens(tokens, at+3, 'number', 'timesep', 'number')) {\n                if (matchTokens(tokens, at+6, ')')) {\n                    const add_or_subtract = tokens[at+2][0] === '+' ? '1' : '-1';\n                    const minutes = getMinutesByHoursMinutes(tokens, nrule, at+3) * add_or_subtract;\n                    if (minutes === 0)\n                        parsing_warnings.push([ nrule, at+5, t('zero calculation') ]\n                            );\n                    return minutes;\n                } else {\n                    error = [ at+6, '. ' + t('missing', {'symbol': ')'}) + '.'];\n                }\n            } else {\n                error = [ at+5, ' ' + t('(time)') + '.'];\n            }\n        } else {\n            error = [ at+2, '. ' + t('expected', {'symbol': '+\" or \"-'})];\n        }\n\n        if (error)\n            throw formatWarnErrorMessage(nrule, error[0],\n                 t('calculation syntax')+ error[1]);\n    }\n    /* }}} */\n    /* }}} */\n\n    /* Weekday range parser (Mo,We-Fr,Sa[1-2,-1],PH). {{{\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position where the weekday tokens could be.\n     * :param rule: Reference to rule object.\n     * :param nrule: Rule number starting with 0.\n     * :returns: Position at which the token does not belong to the selector anymore.\n     */\n    function parseWeekdayRange(tokens, at, rule, in_holiday_selector, nrule) {\n        if (!in_holiday_selector) {\n            in_holiday_selector = true;\n            tokens[at][3] = 'weekday';\n        }\n\n        for (; at < tokens.length; at++) {\n            if (matchTokens(tokens, at, 'weekday', '[')) {\n                // Conditional weekday (Mo[3])\n                const numbers = [];\n\n                // Get list of constraints\n                const endat = parseNumRange(tokens, at+2, function(from, to, at) {\n\n                    // bad number\n                    if (from === 0 || from < -5 || from > 5)\n                        throw formatWarnErrorMessage(nrule, at,\n                            t('number -5 to 5'));\n\n                    if (from === to) {\n                        numbers.push(from);\n                    } else if (from < to) {\n                        for (let i = from; i <= to; i++) {\n                            // bad number\n                            if (i === 0 || i < -5 || i > 5)\n                                throw formatWarnErrorMessage(nrule, at+2,\n                                    t('number -5 to 5'));\n\n                            numbers.push(i);\n                        }\n                    } else {\n                        throw formatWarnErrorMessage(nrule, at+2,\n                            t('bad range',{'from': from, 'to': to}));\n                    }\n                });\n\n                if (!matchTokens(tokens, endat, ']')) {\n                    throw formatWarnErrorMessage(\n                        nrule,\n                        endat + (typeof tokens[endat] === 'object' ? 0 : -1),\n                        t('] or more numbers')\n                    );\n                }\n\n                const add_days = getMoveDays(tokens, endat+1, 6, 'constrained weekdays');\n                week_stable = false;\n\n                // Create selector for each list element.\n                for (let nnumber = 0; nnumber < numbers.length; nnumber++) {\n\n                    rule.weekday.push(function(weekday, number, add_days) { return function(date) {\n                        const date_num = getValueForDate(date, false); // Year not needed to distinguish.\n                        const start_of_this_month = new Date(date.getFullYear(), date.getMonth(), 1);\n                        const start_of_next_month = new Date(date.getFullYear(), date.getMonth() + 1, 1);\n\n                        const target_day_this_month = getDateForConstrainedWeekday(date.getFullYear(), date.getMonth(), weekday, [ number ]);\n\n                        let target_day_with_added_days_this_month = new Date(target_day_this_month.getFullYear(),\n                            target_day_this_month.getMonth(), target_day_this_month.getDate() + add_days);\n\n                        // The target day with added days can be before this month\n                        if (target_day_with_added_days_this_month.getTime() < start_of_this_month.getTime()) {\n                            // but in this case, the target day without the days added needs to be in this month\n                            if (target_day_this_month.getTime() >= start_of_this_month.getTime()) {\n                                // so we calculate it for the month\n                                // following this month and hope that the\n                                // target day will actually be this month.\n\n                                target_day_with_added_days_this_month = dateAtNextWeekday(\n                                    new Date(date.getFullYear(), date.getMonth() + (number > 0 ? 0 : 1) + 1, 1), weekday);\n                                target_day_this_month.setDate(target_day_with_added_days_this_month.getDate()\n                                    + (number + (number > 0 ? -1 : 0)) * 7 + add_days);\n                            } else {\n                                // Calculated target day is not inside this month\n                                // therefore the specified weekday (e.g. fifth Sunday)\n                                // does not exist this month. Try it next month.\n                                return [false, start_of_next_month];\n                            }\n                        } else if (target_day_with_added_days_this_month.getTime() >= start_of_next_month.getTime()) {\n                            // The target day is in the next month. If the target day without the added days is not in this month\n                            if (target_day_this_month.getTime() >= start_of_next_month.getTime())\n                                return [false, start_of_next_month];\n                        }\n\n                        let target_day_with_added_moved_days_this_month;\n                        if (add_days > 0) {\n                            target_day_with_added_moved_days_this_month = dateAtNextWeekday(\n                                new Date(date.getFullYear(), date.getMonth() + (number > 0 ? 0 : 1) -1, 1), weekday);\n                            target_day_with_added_moved_days_this_month.setDate(target_day_with_added_moved_days_this_month.getDate()\n                                + (number + (number > 0 ? -1 : 0)) * 7 + add_days);\n\n                            if (date_num === getValueForDate(target_day_with_added_moved_days_this_month, false))\n                                return [true, dateAtDayMinutes(date, minutes_in_day)];\n                        } else if (add_days < 0) {\n                            target_day_with_added_moved_days_this_month = dateAtNextWeekday(\n                                new Date(date.getFullYear(), date.getMonth() + (number > 0 ? 0 : 1) + 1, 1), weekday);\n                            target_day_with_added_moved_days_this_month.setDate(target_day_with_added_moved_days_this_month.getDate()\n                                + (number + (number > 0 ? -1 : 0)) * 7 + add_days);\n\n                            if (target_day_with_added_moved_days_this_month.getTime() >= start_of_next_month.getTime()) {\n                                if (target_day_with_added_days_this_month.getTime() >= start_of_next_month.getTime())\n                                    return [false, target_day_with_added_moved_days_this_month];\n                            } else {\n                                if (target_day_with_added_days_this_month.getTime() < start_of_next_month.getTime()\n                                    && getValueForDate(target_day_with_added_days_this_month, false) === date_num)\n                                    return [true, dateAtDayMinutes(date, minutes_in_day)];\n\n                                target_day_with_added_days_this_month = target_day_with_added_moved_days_this_month;\n                            }\n                        }\n\n                        // we hit the target day\n                        const currentDateOnly = new Date(date.getFullYear(), date.getMonth(), date.getDate());\n                        const targetDateOnly = new Date(target_day_with_added_days_this_month.getFullYear(), target_day_with_added_days_this_month.getMonth(), target_day_with_added_days_this_month.getDate());\n\n                        if (currentDateOnly.getTime() === targetDateOnly.getTime()) {\n                            return [true, dateAtDayMinutes(date, minutes_in_day)];\n                        }\n\n                        // we're before target day\n                        if (currentDateOnly.getTime() < targetDateOnly.getTime()) {\n                            return [false, target_day_with_added_days_this_month];\n                        }\n\n                        // we're after target day, set check date to next month\n                        return [false, start_of_next_month];\n                    }}(tokens[at][0], numbers[nnumber], add_days[0]));\n                }\n\n                at = endat + 1 + add_days[1];\n            } else if (matchTokens(tokens, at, 'weekday')) {\n                // Single weekday (Mo) or weekday range (Mo-Fr)\n                const is_range = matchTokens(tokens, at+1, '-', 'weekday');\n\n                let weekday_from = tokens[at][0];\n                let weekday_to = is_range ? tokens[at+2][0] : weekday_from;\n\n                let inside = true;\n\n                // handle reversed range\n                if (weekday_to < weekday_from) {\n                    const tmp = weekday_to;\n                    weekday_to = weekday_from - 1;\n                    weekday_from = tmp + 1;\n                    inside = false;\n                }\n                const weekday_list = Array.apply(0, Array(weekday_to - weekday_from + 1)).map(function (_, index) {\n                    return index + weekday_to;\n                });\n                if (typeof rule_infos[nrule] === 'undefined') {\n                    rule_infos[nrule] = {};\n                }\n                if (typeof rule_infos[nrule]['week_days'] === 'object') {\n                    Array.prototype.push.apply(rule_infos[nrule]['week_days'], weekday_list);\n                } else {\n                    rule_infos[nrule]['week_days'] = weekday_list;\n                }\n\n                if (weekday_to < weekday_from) { // handle full range\n                    rule.weekday.push(function() { return [true]; });\n                    // Not needed. If there is no selector it automatically matches everything.\n                    // WRONG: This only works if there is no other selector in this selector group ...\n                } else {\n                    rule.weekday.push(function(weekday_from, weekday_to, inside) { return function(date) {\n                        const ourweekday = date.getDay();\n\n                        if (ourweekday < weekday_from || ourweekday > weekday_to) {\n                            return [!inside, dateAtNextWeekday(date, weekday_from)];\n                        } else {\n                            return [inside, dateAtNextWeekday(date, weekday_to + 1)];\n                        }\n                    }}(weekday_from, weekday_to, inside));\n                }\n\n                at += is_range ? 3 : 1;\n            } else if (matchTokens(tokens, at, 'holiday')) {\n                week_stable = false;\n                return parseHoliday(tokens, at, rule, true, in_holiday_selector);\n            } else if (matchTokens(tokens, at - 1, ',')) { // additional rule\n                throw formatWarnErrorMessage(\n                    nrule,\n                    at - 1,\n                    t('additional rule no sense'));\n            } else {\n                throw formatWarnErrorMessage(nrule, at, t('unexpected token weekday range', {'token': tokens[at][1]}));\n            }\n\n            if (!matchTokens(tokens, at, ',')) {\n                break;\n            }\n        }\n\n        return at;\n    }\n    /* }}} */\n\n    /* Get the number of days a date should be moved (if any). {{{\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position where the date moving tokens could be.\n     * :param max_differ: Maximal number of days to move (could also be zero if there are no day move tokens).\n     * :returns: Array:\n     *            0. Days to add.\n     *            1. How many tokens.\n     */\n    function getMoveDays(tokens, at, max_differ, name) {\n        const add_days = [ 0, 0 ]; // [ 'days to add', 'how many tokens' ]\n        add_days[0] = matchTokens(tokens, at, '+') || (matchTokens(tokens, at, '-') ? -1 : 0);\n        if (add_days[0] !== 0 && matchTokens(tokens, at+1, 'number', 'calcday')) {\n            // continues with '+ 5 days' or something like that\n            if (tokens[at+1][0] > max_differ)\n                throw formatWarnErrorMessage(nrule, at+2,\n                    t('max differ',{'maxdiffer': max_differ, 'name': name}));\n            add_days[0] *= tokens[at+1][0];\n            if (add_days[0] === 0 && !done_with_warnings)\n                parsing_warnings.push([ nrule, at+2, t('adding 0') ]);\n            add_days[1] = 3;\n        } else {\n            add_days[0] = 0;\n        }\n        return add_days;\n    }\n    /* }}} */\n\n    /* Holiday parser for public and school holidays (PH,SH) {{{\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position where to start.\n     * :param rule: Reference to rule object.\n     * :param push_to_weekday: Will push the selector into the weekday selector array which has the desired side effect of working in conjunction with the weekday selectors (either the holiday match or the weekday), which is the normal and expected behavior.\n     * :returns: Position at which the token does not belong to the selector anymore.\n     */\n    function parseHoliday(tokens, at, rule, push_to_weekday, in_holiday_selector) {\n        if (!in_holiday_selector) {\n\n            if (push_to_weekday)\n                tokens[at][3] = 'weekday';\n            else\n                tokens[at][3] = 'holiday'; // Could also be holiday but this is not important here.\n        }\n\n        for (; at < tokens.length; at++) {\n            if (matchTokens(tokens, at, 'holiday')) {\n                if (tokens[at][0] === 'PH') {\n                    const applying_holidays = getMatchingHoliday(tokens[at][0]);\n\n                    // Only allow moving one day in the past or in the future.\n                    // This makes implementation easier because only one holiday is assumed to be moved to the next year.\n                    const add_days = getMoveDays(tokens, at+1, 1, 'public holiday');\n\n                    const selector = function(applying_holidays, add_days) { return function(date) {\n\n                        const holidays = getApplyingHolidaysForYear(applying_holidays, date.getFullYear(), add_days);\n                        // Needs to be calculated each time because of movable days.\n\n                        const date_num = getValueForDate(date, true);\n\n                        for (let i = 0; i < holidays.length; i++) {\n                            const next_holiday_date_num = getValueForDate(holidays[i][0], true);\n\n                            if (date_num < next_holiday_date_num) {\n\n                                if (add_days[0] > 0) {\n                                    // Calculate the last holiday from previous year to tested against it.\n                                    const holidays_last_year = getApplyingHolidaysForYear(applying_holidays, date.getFullYear() - 1, add_days);\n                                    const last_holiday_last_year = holidays_last_year[holidays_last_year.length - 1];\n                                    const last_holiday_last_year_num = getValueForDate(last_holiday_last_year[0], true);\n\n                                    if (date_num < last_holiday_last_year_num ) {\n                                        return [ false, last_holiday_last_year[0] ];\n                                    } else if (date_num === last_holiday_last_year_num) {\n                                        return [true, dateAtDayMinutes(last_holiday_last_year[0], minutes_in_day),\n                                            'Day after ' +last_holiday_last_year[1] ];\n                                    }\n                                }\n\n                                return [ false, holidays[i][0] ];\n                            } else if (date_num === next_holiday_date_num) {\n                                return [true, new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1),\n                                    (add_days[0] > 0 ? 'Day after ' : (add_days[0] < 0 ? 'Day before ' : '')) + holidays[i][1] ];\n                            }\n                        }\n\n                        if (add_days[0] < 0) {\n                            // Calculate the first holiday from next year to tested against it.\n                            const holidays_next_year = getApplyingHolidaysForYear(applying_holidays, date.getFullYear() + 1, add_days);\n                            const first_holidays_next_year = holidays_next_year[0];\n                            const first_holidays_next_year_num = getValueForDate(first_holidays_next_year[0], true);\n                            if (date_num === first_holidays_next_year_num) {\n                                return [true, dateAtDayMinutes(first_holidays_next_year[0], minutes_in_day),\n                                    'Day before ' + first_holidays_next_year[1] ];\n                            }\n                        }\n\n                        // continue next year\n                        return [ false, new Date(holidays[0][0].getFullYear() + 1,\n                                holidays[0][0].getMonth(),\n                                holidays[0][0].getDate()) ];\n\n                    }}(applying_holidays, add_days);\n\n                    if (push_to_weekday)\n                        rule.weekday.push(selector);\n                    else\n                        rule.holiday.push(selector);\n\n                    at += 1 + add_days[1];\n                } else if (tokens[at][0] === 'SH') {\n                    const applying_holidays = getMatchingHoliday(tokens[at][0]);\n\n                    const selector = function(applying_holidays) { return function(date) {\n                        const date_num = getValueForDate(date);\n\n                        // Iterate over holiday array containing the different holiday ranges.\n                        for (let i = 0; i < applying_holidays.length; i++) {\n\n                            const holiday = getSHForYear(applying_holidays[i], date.getFullYear(), false);\n                            if (typeof holiday === 'undefined') {\n                                continue;\n                            }\n\n                            for (let h = 0; h < holiday.length; h+=4) {\n                                let holiday_to_plus = new Date(date.getFullYear(), holiday[2+h] - 1, holiday[3+h] + 1);\n                                const holiday_from = (holiday[0+h] - 1) * 100 + holiday[1+h];\n                                const holiday_to   = (holiday[2+h] - 1) * 100 + holiday[3+h];\n                                holiday_to_plus  = getValueForDate(holiday_to_plus);\n\n                                // console.log(`holiday_from: ${holiday_from}, holiday_to: ${holiday_to}, holiday_to_plus: ${holiday_to_plus}`);\n\n                                const holiday_ends_next_year = holiday_to < holiday_from;\n\n                                if (date_num < holiday_from) { // date is before selected holiday\n\n                                    // check if we are in the holidays from the last year spanning into this year\n                                    const last_year_holiday = getSHForYear(applying_holidays[applying_holidays.length - 1], date.getFullYear() - 1, false);\n                                    if (typeof last_year_holiday === 'object') {\n                                        const last_year_holiday_from = (last_year_holiday[last_year_holiday.length - 4] - 1) * 100\n                                            + last_year_holiday[last_year_holiday.length - 3]; // e.g. 1125\n                                        const last_year_holiday_to   = (last_year_holiday[last_year_holiday.length - 2] - 1) * 100\n                                            + last_year_holiday[last_year_holiday.length - 1]; // e.g. 0005\n                                        // console.log(last_year_holiday_from, last_year_holiday_to);\n\n                                        if (last_year_holiday_from > last_year_holiday_to && date_num <= last_year_holiday_to) {\n                                            return [ true, new Date(date.getFullYear(),\n                                                last_year_holiday[last_year_holiday.length - 2] - 1,\n                                                last_year_holiday[last_year_holiday.length - 1] + 1),\n                                                applying_holidays[applying_holidays.length - 1].name ];\n                                        } else {\n                                            return [ false, new Date(date.getFullYear(), holiday[0+h] - 1, holiday[1+h]) ];\n                                        }\n                                    } else { /* School holidays for last year are not defined. */\n                                        return [ false, new Date(date.getFullYear(), holiday[0+h] - 1, holiday[1+h]) ];\n                                    }\n                                } else if (holiday_from <= date_num && (date_num <= holiday_to || holiday_ends_next_year)) {\n                                    return [ true, new Date(date.getFullYear() + holiday_ends_next_year, holiday[2+h] - 1, holiday[3+h] + 1),\n                                        applying_holidays[i].name ];\n                                } else if (holiday_to_plus === date_num) { // selected holiday end is equal to month and day\n                                    if (h + 4 < holiday.length) { // next holiday is next date range of the same holidays\n                                        h += 4;\n                                        return [ false, new Date(date.getFullYear(), holiday[0+h] - 1, holiday[1+h]) ];\n                                    } else {\n                                        /* Because not all school holidays\n                                         * have to apply each year this\n                                         * part has been simplified which\n                                         * makes the implementation a bit\n                                         * less efficient but reduces\n                                         * complexity.\n                                         */\n                                        return [ false, new Date(date.getFullYear(), holiday[2+h] - 1, holiday[3+h] + 2) ];\n                                    }\n                                }\n                            }\n                        }\n                        throw formatLibraryBugMessage(t('no SH definition', {\n                            'name': '',\n                            'year': date.getFullYear(),\n                        }), 'library bug PR only');\n                    }}(applying_holidays);\n\n                    if (push_to_weekday)\n                        rule.weekday.push(selector);\n                    else\n                        rule.holiday.push(selector);\n                    at += 1; // FIXME: test\n                }\n            } else if (matchTokens(tokens, at, 'weekday')) {\n                return parseWeekdayRange(tokens, at, rule, true, nrule);\n            } else if (matchTokens(tokens, at - 1, ',')) { // additional rule\n                throw formatWarnErrorMessage(\n                    nrule,\n                    at - 1,\n                    t('additional rule no sense'));\n            } else {\n                throw formatWarnErrorMessage(nrule, at, t('unexpected token holiday', {'token': tokens[at][1]}));\n            }\n\n            if (!matchTokens(tokens, at, ','))\n                break;\n        }\n\n        return at;\n    }\n\n    // Helpers for holiday parsers {{{\n\n    /* Returns a number for a date which can then be used to compare just the dates (without the time). {{{\n     *\n     * This is necessary because a selector could be called for the middle of the day and we need to tell if it matches that day.\n     * Example: Returns 20150015 for Jan 15 2015.\n     *\n     * :param date: Date object.\n     * :param include_year: Boolean. If true include the year.\n     * :returns: Number for the date.\n     */\n    function getValueForDate(date, include_year) {\n        // Implicit because undefined evaluates to false.\n        // include_year = typeof include_year !== 'undefined' ? include_year : false;\n\n        return (include_year ? (date.getFullYear() * 10000) : 0) + (date.getMonth() * 100) + date.getDate();\n    }\n    /* }}} */\n\n    /* Return the school holiday definition e.g. [ 5, 25, to 6, 5 ], for the specified year {{{\n     *\n     * :param SH_hash:\n     * :param year: Year as integer.\n     * :param fatal: Defines the behavior in case no definition is find. Throw an error if set to true. Return return undefined otherwise.\n     * :returns: school holidays for the given year.\n     */\n    function getSHForYear(SH_hash, year, fatal) {\n        if (typeof fatal !== 'boolean') {\n            fatal = true;\n        }\n\n        let holiday = SH_hash[year];\n        if (typeof holiday === 'undefined') {\n            holiday = SH_hash['default']; // applies for any year without explicit definition\n            if (typeof holiday === 'undefined') {\n                if (fatal) {\n                    throw formatLibraryBugMessage(t('no SH definition', {\n                        'name': SH_hash.name + ' ',\n                        'year': year,\n                    }), 'library bug PR only');\n                } else {\n                    return undefined;\n                }\n            }\n        }\n        return holiday;\n    }\n    /* }}} */\n\n    /* Return closest holiday definition available. {{{\n     *\n     * First try to get the state, if missing get the country wide holidays\n     * (which can on it’s own be limited to some states).\n     *\n     * :param type_of_holidays: Choices: PH, SH.\n     * :returns: Public or school holiday list.\n     */\n    function getMatchingHoliday(type_of_holidays) {\n        if (typeof location_cc !== 'string') {\n            /* We have no idea which holidays do apply because the country code was not provided. */\n            throw t('no country code');\n        }\n\n        if (!holiday_definitions[location_cc]) {\n            throw formatLibraryBugMessage(t('no holiday definition', {\n                'name': type_of_holidays,\n                'cc': location_cc,\n            }), 'library bug PR only');\n        }\n\n        let matching_holiday = [];\n        if (typeof location_state === 'string'\n            && typeof holiday_definitions[location_cc][location_state] === 'object'\n            && typeof holiday_definitions[location_cc][location_state][type_of_holidays] === 'object') {\n\n            /* If holiday_definitions for the state are specified,\n             * use it and ignore lesser specific ones (for the\n             * country).\n             */\n\n            const country_holidays = holiday_definitions[location_cc][type_of_holidays] || [];\n            const state_holidays = holiday_definitions[location_cc][location_state][type_of_holidays];\n            if (type_of_holidays === 'PH') {\n                matching_holiday = state_holidays;\n            } else if (!country_holidays.length) {\n                matching_holiday = state_holidays;\n            } else {\n                // Merge country and state holidays chronologically\n                const country_holiday_names = country_holidays.map(function(country_holiday) {\n                    return country_holiday.name;\n                });\n                matching_holiday.push.apply(matching_holiday, country_holidays);\n                matching_holiday.push.apply(matching_holiday, state_holidays.filter(function is_not_a_country_holiday(state_holiday) {\n                    return country_holiday_names.indexOf(state_holiday.name) === -1;\n                }));\n                matching_holiday.sort(function(h1, h2) {\n                    const h1_year = Object.keys(h1).find(function(k) {return k !== 'name';});\n                    const h2_year = Object.keys(h2).find(function(k) {return k !== 'name';});\n                    const h1_date = h1[h1_year];\n                    const h2_date = h2[h2_year];\n                    // compare both months, or to break a tie both days\n                    return (h1_date[0] - h2_date[0]) || (h1_date[1] - h2_date[1]);\n                });\n            }\n        } else if (holiday_definitions[location_cc][type_of_holidays]) {\n            /* Holidays are defined country wide. Some\n             * countries only have country-wide holiday definitions\n             * so that is ok too.\n             */\n            const applying_holidays_for_country = holiday_definitions[location_cc][type_of_holidays];\n\n            switch (type_of_holidays) {\n                case 'PH':\n                    applying_holidays_for_country.forEach(function (holiday_item) {\n                        /* Holidays in the country-wide scope can be limited to certain states. */\n                        if ('only_states' in holiday_item) {\n                            if (-1 === holiday_item.only_states.indexOf(location_state)) {\n                                return;\n                            }\n                        }\n\n                        matching_holiday.push(holiday_item);\n                    });\n                    break;\n                case 'SH':\n                    matching_holiday = applying_holidays_for_country;\n                    break;\n            }\n        } else {\n            throw formatLibraryBugMessage(t('no holiday definition state', {\n                'name': type_of_holidays,\n                'cc': location_cc,\n                'state': location_state,\n            }), 'library bug PR only');\n        }\n\n        if (matching_holiday.length === 0) {\n            throw formatLibraryBugMessage(t('no holiday definition', {\n                'name': type_of_holidays,\n                'cc': location_cc,\n            }), 'library bug PR only');\n        }\n\n        return matching_holiday;\n    }\n    /* }}} */\n\n    /* Return variable dates used for holiday calculation. {{{\n     *\n     * :param year: Year as integer.\n     * :returns: Hash of variables dates. Key is the name of the variable date. Value is the variable date date object.\n     */\n    function getMovableEventsForYear(year) {\n        /* Calculate easter {{{ */\n        const C = Math.floor(year/100);\n        const N = year - 19*Math.floor(year/19);\n        const K = Math.floor((C - 17)/25);\n        let I = C - Math.floor(C/4) - Math.floor((C - K)/3) + 19*N + 15;\n        I = I - 30*Math.floor((I/30));\n        I = I - Math.floor(I/28)*(1 - Math.floor(I/28)*Math.floor(29/(I + 1))*Math.floor((21 - N)/11));\n        let J = year + Math.floor(year/4) + I + 2 - C + Math.floor(C/4);\n        J = J - 7*Math.floor(J/7);\n        const L = I - J;\n        const M = 3 + Math.floor((L + 40)/44);\n        const D = L + 28 - 31*Math.floor(M/4);\n        /* }}} */\n\n        /* Calculate orthodox easter {{{ */\n        const oA = year % 4;\n        const oB = year % 7;\n        const oC = year % 19;\n        const oD = (19*oC + 15) % 30;\n        const oE = (2*oA+4*oB - oD + 34) % 7;\n        const oF = oD+oE;\n\n        let oDate;\n        if (oF < 9) {\n            oDate = new Date(year, 4-1, oF+4);\n        } else {\n            if ((oF+4)<31) {\n                oDate = new Date(year, 4-1, oF+4);\n            } else {\n                oDate = new Date(year, 5-1, oF-26);\n            }\n        }\n        /* }}} */\n\n        /* Calculate last Sunday in February {{{ */\n        const lastFebruaryDay = new Date(year, 2, 0);\n        const lastFebruarySunday = lastFebruaryDay.getDate() - lastFebruaryDay.getDay();\n        /* }}} */\n\n        /* Calculate Victoria Day. last Monday before or on May 24 {{{ */\n        const may_24 = new Date(year, 4, 24);\n        const victoriaDay = 24  - ((6 + may_24.getDay()) % 7);\n        /* }}} */\n\n        /* Calculate Canada Day. July 1st unless 1st is on Sunday, then July 2. {{{ */\n        const july_1 = new Date(year, 6, 1);\n        const canadaDay = july_1.getDay() === 0 ? 2 : 1;\n        /* }}} */\n\n        /* Calculation of the spring and autumnal equinoxes (for Public holidays in Japan). {{{ */\n        function springEquinoxCalc(year){\n            if(year >= 1900 && year <= 1923){\n                if(year % 4 === 3) return new Date(year, 2, 22)\n                else return new Date(year, 2, 21)\n            } else if(year >= 1924 && year <= 1959){\n                return new Date(year, 2, 21)\n            } else if(year >= 1960 && year <= 1991){\n                if(year % 4 === 0) return new Date(year, 2, 20)\n                else return new Date(year, 2, 21)\n            } else if(year >= 1992 && year <= 2023){\n                if(year % 4 === 0 || year % 4 === 1) return new Date(year, 2, 20)\n                else return new Date(year, 2, 21)\n            } else if(year >= 2024 && year <= 2055){\n                if(year % 4 === 3) return new Date(year, 2, 21)\n                else return new Date(year, 2, 20)\n            } else if(year >= 2056 && year <= 2091){\n                return new Date(year, 2, 20)\n            } else if(year >= 2092 && year <= 2099){\n                if(year % 4 === 0) return new Date(year, 2, 19)\n                else return new Date(year, 2, 20)\n            }\n        }\n\n        function autumnalEquinoxCalc(year){\n            if(year >= 1900 && year <= 1919){\n                if(year % 4 === 0) return new Date(year, 8, 23)\n                else return new Date(year, 8, 24)\n            } else if(year >= 1920 && year <= 1947){\n                if(year % 4 === 0 || year % 4 === 1) return new Date(year, 8, 23)\n                else return new Date(year, 8, 24)\n            } else if(year >= 1948 && year <= 1979){\n                if(year % 4 === 3) return new Date(year, 8, 24)\n                else return new Date(year, 8, 23)\n            } else if(year >= 1980 && year <= 2011){\n                return new Date(year, 8, 23)\n            } else if(year >= 2012 && year <= 2043){\n                if(year % 4 === 0) return new Date(year, 8, 22)\n                else return new Date(year, 8, 23)\n            }  else if(year >= 2044 && year <= 2075){\n                if(year % 4 === 0 || year % 4 === 1) return new Date(year, 8, 22)\n                else return new Date(year, 8, 23)\n            } else if(year >= 2076 && year <= 2099){\n                if(year % 4 === 3) return new Date(year, 8, 23)\n                else return new Date(year, 8, 22)\n            }\n        }\n\n        /* Helper functions {{{ */\n        function firstWeekdayOfMonth(month, weekday){\n            const first = new Date(year, month, 1);\n            return 1 + ((7 + weekday - first.getDay()) % 7);\n        }\n\n        function lastWeekdayOfMonth(month, weekday){\n            const last = new Date(year, month+1, 0);\n            const offset = ((7 + last.getDay() - weekday) % 7);\n            return last.getDate() - offset;\n        }\n\n        function getDateOfWeekdayInDateRange(weekday, start_date){\n            let days_to_dest_date = weekday - start_date.getDay();\n            if (days_to_dest_date < 0) {\n                days_to_dest_date += 7;\n            }\n            start_date.setDate(start_date.getDate() + days_to_dest_date);\n            return start_date;\n        }\n\n        /* Date of next weekday range. {{{\n         *\n         * :param first_weekday: First weekday in range of wanted weekday (1 is Mo).\n         * :param last_weekday: Last weekday in range of wanted weekday (1 is Mo).\n         * :param start_date: Earliest possible date to consider.\n         * :returns: start_date if in weekday range, otherwise the next day which is in range.\n         */\n        function getDateOfNextWeekdayRange(first_weekday, last_weekday, start_date){\n            if (first_weekday >= last_weekday) {\n                throw formatLibraryBugMessage('Not implemented yet.');\n            }\n\n            if (first_weekday <= start_date.getDay() && start_date.getDay() <= last_weekday) {\n                return start_date;\n            } else {\n                let days_to_dest_date = first_weekday - start_date.getDay();\n                if (days_to_dest_date < 0) {\n                    days_to_dest_date += 7;\n                }\n                start_date.setDate(start_date.getDate() + days_to_dest_date);\n                return start_date;\n            }\n\n        }\n        /* }}} */\n\n        return {\n            'easter'                : new Date(year, M - 1, D),\n            'orthodox easter'       : oDate,\n            'victoriaDay'           : new Date(year,  4, victoriaDay),\n            'canadaDay'             : new Date(year,  6, canadaDay),\n            'firstJanuaryMonday'    : new Date(year,  0, firstWeekdayOfMonth(0, 1)),\n            'firstFebruaryMonday'   : new Date(year,  1, firstWeekdayOfMonth(1, 1)),\n            'lastFebruarySunday'    : new Date(year,  1, lastFebruarySunday),\n            'firstMarchMonday'      : new Date(year,  2, firstWeekdayOfMonth(2, 1)),\n            'firstAprilMonday'      : new Date(year,  3, firstWeekdayOfMonth(3, 1)),\n            'firstMayMonday'        : new Date(year,  4, firstWeekdayOfMonth(4, 1)),\n            'firstJuneMonday'       : new Date(year,  5, firstWeekdayOfMonth(5, 1)),\n            'firstJulyMonday'       : new Date(year,  6, firstWeekdayOfMonth(6, 1)),\n            'firstAugustMonday'     : new Date(year,  7, firstWeekdayOfMonth(7, 1)),\n            'firstSeptemberMonday'  : new Date(year,  8, firstWeekdayOfMonth(8, 1)),\n            'firstSeptemberTuesday' : new Date(year,  8, firstWeekdayOfMonth(8, 2)),\n            'firstSeptemberSunday'  : new Date(year,  8, firstWeekdayOfMonth(8, 0)),\n            'firstOctoberMonday'    : new Date(year,  9, firstWeekdayOfMonth(9, 1)),\n            'firstNovemberMonday'   : new Date(year, 10, firstWeekdayOfMonth(10, 1)),\n            'firstNovemberTuesday'  : new Date(year, 10, firstWeekdayOfMonth(10, 2)),\n            'firstMarchTuesday'     : new Date(year,  2, firstWeekdayOfMonth(2, 2)),\n            'firstAugustTuesday'    : new Date(year,  7, firstWeekdayOfMonth(7, 2)),\n            'firstAugustFriday'     : new Date(year,  7, firstWeekdayOfMonth(7, 5)),\n            'firstNovemberThursday' : new Date(year, 10, firstWeekdayOfMonth(10, 4)),\n            'lastMayMonday'         : new Date(year,  4, lastWeekdayOfMonth(4, 1)),\n            'lastMarchMonday'       : new Date(year,  2, lastWeekdayOfMonth(2, 1)),\n            'lastAprilMonday'       : new Date(year,  3, lastWeekdayOfMonth(3, 1)),\n            'lastAprilFriday'       : new Date(year,  3, lastWeekdayOfMonth(3, 5)),\n            'lastAugustMonday'      : new Date(year,  7, lastWeekdayOfMonth(7, 1)),\n            'lastSeptemberMonday'   : new Date(year,  8, lastWeekdayOfMonth(8, 1)),\n            'lastSeptemberFriday'   : new Date(year,  8, lastWeekdayOfMonth(8, 5)),\n            'lastOctoberMonday'     : new Date(year,  9, lastWeekdayOfMonth(9, 1)),\n            'lastOctoberFriday'     : new Date(year,  9, lastWeekdayOfMonth(9, 5)),\n            'nextSaturday20Jun'     : getDateOfWeekdayInDateRange(6, new Date(year, 5, 20)),\n            'nextSaturday31Oct'     : getDateOfWeekdayInDateRange(6, new Date(year, 9, 31)),\n            'nextWednesday16Nov'    : getDateOfWeekdayInDateRange(3, new Date(year, 10, 16)),\n            'nextMo-Fr17March'      : getDateOfNextWeekdayRange(1, 5, new Date(year, 2, 17)),\n            'nextMo-Sa01May'        : getDateOfNextWeekdayRange(1, 6, new Date(year, 4, 1)),\n            'nextMo-Fr12July'       : getDateOfNextWeekdayRange(1, 5, new Date(year, 6, 12)),\n            'nextMo-Sa07August'     : getDateOfNextWeekdayRange(1, 6, new Date(year, 7, 7)),\n            'nextMo-Fr30November'   : getDateOfNextWeekdayRange(1, 5, new Date(year, 10, 30)),\n            'nextMo-Sa25December'   : getDateOfNextWeekdayRange(1, 6, new Date(year, 11, 25)),\n            'springEquinox'         : springEquinoxCalc(year),\n            'autumnalEquinox'       : autumnalEquinoxCalc(year),\n        };\n    }\n    /* }}} */\n\n    function getApplyingHolidaysForYear(applying_holidays, year, add_days) {\n        const movableDays = getMovableEventsForYear(year);\n\n        let sorted_holidays = [];\n        let next_holiday;\n\n        applying_holidays.forEach(function (holiday_item) {\n            if ('fixed_date' in holiday_item) {\n                next_holiday = new Date(year,\n                        holiday_item.fixed_date[0] - 1,\n                        holiday_item.fixed_date[1]\n                    );\n            } else if ('variable_date' in holiday_item) {\n                const selected_movableDay = movableDays[holiday_item.variable_date];\n                if (!selected_movableDay) {\n                    throw t('movable no formula', {'name': holiday_item.name});\n                }\n                let date_offset = 0;\n                if ('offset' in holiday_item) {\n                    date_offset = holiday_item.offset;\n                }\n                next_holiday = new Date(selected_movableDay.getFullYear(),\n                    selected_movableDay.getMonth(),\n                    selected_movableDay.getDate() + date_offset\n                );\n                if (year !== next_holiday.getFullYear()) {\n                    throw t('movable not in year', {\n                        'name': holiday_item.variable_date, 'days': date_offset});\n                }\n            } else {\n                throw formatLibraryBugMessage('Unexpected object: ' + JSON.stringify(holiday_item, null, '    '));\n            }\n\n            if (add_days[0]) {\n                next_holiday.setDate(next_holiday.getDate() + add_days[0]);\n            }\n\n            sorted_holidays.push([ next_holiday, holiday_item.name ]);\n        });\n\n        sorted_holidays = sorted_holidays.sort(function(a,b){\n            if (a[0].getTime() < b[0].getTime()) return -1;\n            if (a[0].getTime() > b[0].getTime()) return 1;\n            return 0;\n        });\n\n        return sorted_holidays;\n    }\n    /* }}} */\n    /* }}} */\n\n    /* Year range parser (2013,2016-2018,2020/2). {{{\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position where to start.\n     * :returns: Position at which the token does not belong to the selector anymore.\n     */\n    function parseYearRange(tokens, at) {\n        tokens[at][3] = 'year';\n        for (; at < tokens.length; at++) {\n            if (matchTokens(tokens, at, 'year')) {\n                let is_range = false,\n                    has_period,\n                    period;\n                if (matchTokens(tokens, at+1, '-', 'year', '/', 'number')) {\n                    is_range   = true;\n                    has_period = true;\n                    period = parseInt(tokens[at+4][0]);\n                    checkPeriod(at+4, period, 'year');\n                } else {\n                    is_range   = matchTokens(tokens, at+1, '-', 'year');\n                    has_period = matchTokens(tokens, at+1, '/', 'number');\n                    if (has_period) {\n                        period = parseInt(tokens[at+2][0]);\n                        checkPeriod(at+2, period, 'year', 'no_end_year');\n                    } else if (matchTokens(tokens, at+1, '+')) {\n                        period = 1;\n                        has_period = 2;\n                    }\n                }\n\n                const year_from = parseInt(tokens[at][0]);\n                // error checking {{{\n                    if (is_range && tokens[at+2][0] <= year_from) {\n                        // handle reversed range\n                        if (tokens[at+2][0] === year_from) {\n                            throw formatWarnErrorMessage(nrule, at, t('year range one year', {'year': year_from }));\n                        } else {\n                            throw formatWarnErrorMessage(nrule, at, t('year range reverse'));\n                        }\n                    }\n                    if (!is_range && year_from < new Date().getFullYear()) {\n                        parsing_warnings.push([ nrule, at, t('year past') ]);\n                    }\n                    if (is_range && tokens[at+2][0] < new Date().getFullYear()) {\n                        parsing_warnings.push([ nrule, at+2, t('year past') ]);\n                    }\n                /* }}} */\n\n                rule.year.push(function(tokens, at, year_from, is_range, has_period, period) { return function(date) {\n                    const ouryear = date.getFullYear();\n                    const year_to = is_range ? parseInt(tokens[at+2][0]) : year_from;\n\n                    if (ouryear < year_from ){\n                        return [false, new Date(year_from, 0, 1)];\n                    } else if (has_period) {\n                        if (year_from <= ouryear) {\n                            if (is_range && ouryear > year_to)\n                                return [false];\n                            if (period > 0) {\n                                if ((ouryear - year_from) % period === 0) {\n                                    return [true, new Date(ouryear + 1, 0, 1)];\n                                } else {\n                                    return [false, new Date(ouryear + period - 1, 0, 1)];\n                                }\n                            }\n                        }\n                    } else if (is_range) {\n                        if (ouryear <= year_to)\n                            return [true, new Date(year_to + 1, 0, 1)];\n                    } else if (ouryear === year_from) {\n                        return [true];\n                    }\n\n                    return [false];\n\n                }}(tokens, at, year_from, is_range, has_period, period));\n\n                at += 1 + (is_range ? 2 : 0) + (has_period ? (has_period === 2 ? 1 : 2) : 0);\n            } else if (matchTokens(tokens, at - 1, ',')) { // additional rule\n                throw formatWarnErrorMessage(nrule, at - 1, t('additional rule no sense'));\n            } else {\n                throw formatWarnErrorMessage(nrule, at, t('unexpected token year range', {'token': tokens[at][1]}));\n            }\n\n            if (!matchTokens(tokens, at, ','))\n                break;\n        }\n\n        return at;\n    }\n    /* }}} */\n\n    /* Week range parser (week 11-20, week 1-53/2). {{{\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position where to start.\n     * :returns: Position at which the token does not belong to the selector anymore.\n     */\n    function parseWeekRange(tokens, at) {\n        for (; at < tokens.length; at++) {\n            if (matchTokens(tokens, at, 'week')) {\n                at++;\n            }\n            if (matchTokens(tokens, at, 'number')) {\n                const is_range = matchTokens(tokens, at+1, '-', 'number');\n                let period = 0;\n                const week_from = tokens[at][0];\n                const week_to   = is_range ? tokens[at+2][0] : week_from;\n                if (week_from > week_to) {\n                    throw formatWarnErrorMessage(nrule, at+2, t('week range reverse'));\n                }\n                if (week_from < 1) {\n                    throw formatWarnErrorMessage(nrule, at, t('week negative'));\n                }\n                if (week_to > 53) {\n                    throw formatWarnErrorMessage(nrule, is_range ? at+2 : at, t('week exceed'));\n                }\n                if (is_range) {\n                    period = matchTokens(tokens, at+3, '/', 'number');\n                    if (period) {\n                        period = tokens[at+4][0];\n                        tokens[at+4][4] = 'positive_number';\n                        if (period < 2) {\n                            throw formatWarnErrorMessage(nrule, at+4, t('week period less than 2', {\n                                'weekfrom': week_from, 'weekto': week_to, 'period': period}));\n                        } else if (period > 26) {\n                            throw formatWarnErrorMessage(nrule, at+4, t('week period greater than 26', {\n                                'weekfrom': week_from\n                            }));\n                        }\n                    }\n                }\n\n                if (week_stable && (!(week_from <= 1 && week_to >= 53) || period)) {\n                    week_stable = false;\n                }\n\n                if (!period && week_from === 1 && week_to === 53) {\n                    /* Shortcut and work around bug. */\n                    rule.week.push(function() { return [true]; });\n                } else {\n\n                    rule.week.push(function(week_from, week_to, period) { return function(date) {\n                        const ourweek = getWeekNumber(date);\n\n                        // console.log(\"week_from: %s, week_to: %s\", week_from, week_to);\n                        // console.log(\"ourweek: %s, date: %s\", ourweek, date);\n\n                        // before range\n                        if (ourweek < week_from) {\n                            // console.log(\"Before: \" + getNextDateOfISOWeek(week_from, date));\n                            return [false, getNextDateOfISOWeek(week_from, date)];\n                        }\n\n                        // we're after range, set check date to next year\n                        if (ourweek > week_to) {\n                            // console.log(\"After\");\n                            return [false, getNextDateOfISOWeek(week_from, date)];\n                        }\n\n                        // we're in range\n                        if (period) {\n                            const in_period = (ourweek - week_from) % period === 0;\n                            if (in_period) {\n                                return [true, getNextDateOfISOWeek(ourweek + 1, date)];\n                            } else {\n                                // Calculate how many weeks we need to skip to land on the next period-aligned week\n                                const weeks_until_next_match = period - ((ourweek - week_from) % period);\n                                const next_matching_week = ourweek + weeks_until_next_match;\n                                if (next_matching_week <= week_to) {\n                                    return [false, getNextDateOfISOWeek(next_matching_week, date)];\n                                } else {\n                                    // No further match within the range; wrap to the first matching week in the next year\n                                    return [false, getNextDateOfISOWeek(week_from, date)];\n                                }\n                            }\n                        }\n\n                        // console.log(\"Match\");\n                        return [true, getNextDateOfISOWeek(week_to === 53 ? 1 : week_to + 1, date)];\n                    }}(week_from, week_to, period));\n                }\n\n                at += 1 + (is_range ? 2 : 0) + (period ? 2 : 0);\n            } else if (matchTokens(tokens, at - 1, ',')) { // additional rule\n                throw formatWarnErrorMessage(nrule, at - 1, t('additional rule no sense'));\n            } else {\n                throw formatWarnErrorMessage(nrule, at, t('unexpected token week range', {'token': tokens[at][1]}));\n            }\n\n            if (!matchTokens(tokens, at, ','))\n                break;\n        }\n\n        return at;\n    }\n\n    // https://stackoverflow.com/a/6117889\n    /* For a given date, get the ISO week number.\n     *\n     * Based on information at:\n     *\n     *    http://www.merlyn.demon.co.uk/weekcalc.htm#WNR\n     *\n     * Algorithm is to find nearest Thursday, it's year\n     * is the year of the week number. Then get weeks\n     * between that date and the first day of that year.\n     *\n     * Note that dates in one year can be weeks of previous\n     * or next year, overlap is up to 3 days.\n     *\n     * e.g. 2014/12/29 is Monday in week  1 of 2015\n     *      2012/1/1   is Sunday in week 52 of 2011\n     */\n    function getWeekNumber(d) {\n        // Copy date so don't modify original\n        d = new Date(+d);\n        d.setHours(0,0,0,0);\n        // Set to nearest Thursday: current date + 4 - current day number\n        // Make Sunday's day number 7\n        d.setDate(d.getDate() + 4 - (d.getDay()||7));\n        // Get first day of year\n        const yearStart = new Date(d.getFullYear(),0,1);\n        // Calculate full weeks to nearest Thursday\n        return Math.ceil(( ( (d - yearStart) / 86400000) + 1)/7)\n    }\n    // https://stackoverflow.com/a/16591175\n    function getDateOfISOWeek(w, year) {\n        const simple = new Date(year, 0, 1 + (w - 1) * 7);\n        const dow = simple.getDay();\n        const ISOweekStart = simple;\n        if (dow <= 4)\n            ISOweekStart.setDate(simple.getDate() - simple.getDay() + 1);\n        else\n            ISOweekStart.setDate(simple.getDate() + 8 - simple.getDay());\n        return ISOweekStart;\n    }\n    function getNextDateOfISOWeek(week, date) {\n        let next_date;\n        for (let i = -1; i <= 1; i++) {\n            next_date = getDateOfISOWeek(week, date.getFullYear() + i);\n            if (next_date.getTime() > date.getTime()) {\n                return next_date;\n            }\n        }\n        throw formatLibraryBugMessage();\n    }\n    /* }}} */\n\n    /* Month range parser (Jan,Feb-Mar). {{{\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position where to start.\n     * :param push_to_monthday: Will push the selector into the monthday selector array which has the desired side effect of working in conjunction with the monthday selectors (either the month match or the monthday).\n     * :returns: Position at which the token does not belong to the selector anymore.\n     */\n    function parseMonthRange(tokens, at, push_to_monthday, in_selector) {\n        if (!in_selector)\n            tokens[at][3] = 'month';\n\n        for (; at < tokens.length; at++) {\n            // Use parseMonthdayRange if '<month> <daynum>' and not '<month> <hour>:<minute>'\n            if (matchTokens(tokens, at, 'month', 'number') && !matchTokens(tokens, at+2, 'timesep', 'number')) {\n                return parseMonthdayRange(tokens, at, nrule, true);\n            } else if (matchTokens(tokens, at, 'month')) {\n                // Single month (Jan) or month range (Feb-Mar)\n                const is_range = matchTokens(tokens, at+1, '-', 'month');\n\n                let month_from = tokens[at][0];\n                let month_to = is_range ? tokens[at+2][0] : month_from;\n\n                if (is_range && week_stable) {\n                    if (month_from !== (month_to + 1) % 12)\n                        week_stable = false;\n                } else {\n                    week_stable = false;\n                }\n\n                let inside = true;\n\n                // handle reversed range\n                if (month_to < month_from) {\n                    const tmp = month_to;\n                    month_to = month_from - 1;\n                    month_from = tmp + 1;\n                    inside = false;\n                }\n\n                const selector = function(month_from, month_to, inside) { return function(date) {\n                    const ourmonth = date.getMonth();\n\n                    if (month_to < month_from) {\n                        /* Handle full range. */\n                        return [!inside];\n                    }\n\n                    if (ourmonth < month_from || ourmonth > month_to) {\n                        return [!inside, dateAtNextMonth(date, month_from)];\n                    } else {\n                        return [inside, dateAtNextMonth(date, month_to + 1)];\n                    }\n                }}(month_from, month_to, inside);\n\n                if (push_to_monthday === true)\n                    rule.monthday.push(selector);\n                else\n                    rule.month.push(selector);\n\n                at += is_range ? 3 : 1;\n            } else {\n                throw formatWarnErrorMessage(nrule, at, t('unexpected token month range', {'token': tokens[at][1]}));\n            }\n\n            if (!matchTokens(tokens, at, ','))\n                break;\n        }\n\n        return at;\n    }\n\n    function dateAtNextMonth(date, month) {\n        return new Date(date.getFullYear(), month < date.getMonth() ? month + 12 : month);\n    }\n    /* }}} */\n\n    /* Month day range parser (Jan 26-31; Jan 26-Feb 26). {{{\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position where to start.\n     * :param nrule: Rule number starting with 0.\n     * :param push_to_month: Will push the selector into the month selector array which has the desired side effect of working in conjunction with the month selectors (either the month match or the monthday).\n     * :returns: Position at which the token does not belong to the selector anymore.\n     */\n    function parseMonthdayRange(tokens, at, nrule, push_to_month) {\n        if (!push_to_month)\n            tokens[at][3] = 'month';\n\n        for (; at < tokens.length; at++) {\n            let has_year = [];\n            const has_month = [], has_event = [], has_calc = [], has_constrained_weekday = [];\n            has_year[0]  = matchTokens(tokens, at, 'year');\n            has_month[0] = matchTokens(tokens, at+has_year[0], 'month', 'number');\n            has_event[0] = matchTokens(tokens, at+has_year[0], 'event');\n\n            if (has_event[0])\n                has_calc[0] = getMoveDays(tokens, at+has_year[0]+1, 200, 'event like easter');\n\n            let at_range_sep;\n            if (matchTokens(tokens, at+has_year[0], 'month', 'weekday', '[')) {\n                has_constrained_weekday[0] = getConstrainedWeekday(tokens, at+has_year[0]+3);\n                has_calc[0] = getMoveDays(tokens, has_constrained_weekday[0][1], 6, 'constrained weekdays');\n                at_range_sep = has_constrained_weekday[0][1] + (typeof has_calc[0] === 'object' && has_calc[0][1] ? 3 : 0);\n            } else {\n                at_range_sep = at+has_year[0]\n                    + (has_event[0]\n                        ? (typeof has_calc[0] === 'object' && has_calc[0][1] ? 4 : 1)\n                        : 2);\n            }\n\n            let at_sec_event_or_month;\n            if ((has_month[0] || has_event[0] || has_constrained_weekday[0]) && matchTokens(tokens, at_range_sep, '-')) {\n                has_year[1] = matchTokens(tokens, at_range_sep+1, 'year');\n                at_sec_event_or_month = at_range_sep+1+has_year[1];\n                has_month[1] = matchTokens(tokens, at_sec_event_or_month, 'month', 'number');\n                if (!has_month[1]) {\n                    has_event[1] = matchTokens(tokens, at_sec_event_or_month, 'event');\n                    if (has_event[1]) {\n                        has_calc[1] = getMoveDays(tokens, at_sec_event_or_month+1, 366, 'event like easter');\n                    } else if (matchTokens(tokens, at_sec_event_or_month, 'month', 'weekday', '[')) {\n                        has_constrained_weekday[1] = getConstrainedWeekday(tokens, at_sec_event_or_month+3);\n                        has_calc[1] = getMoveDays(tokens, has_constrained_weekday[1][1], 6, 'constrained weekdays');\n                    }\n                }\n            }\n\n            // monthday range like Jan 26-Feb 26 {{{\n            if (has_year[0] === has_year[1] && (has_month[1] || has_event[1] || has_constrained_weekday[1])) {\n\n                if (has_month[0])\n                    checkIfDateIsValid(tokens[at+has_year[0]][0], tokens[at+has_year[0]+1][0], nrule, at+has_year[0]+1);\n                if (has_month[1])\n                    checkIfDateIsValid(tokens[at_sec_event_or_month][0], tokens[at_sec_event_or_month+1][0], nrule, at_sec_event_or_month+1);\n\n                const selector = function(tokens, at, nrule, has_year, has_event, has_calc, at_sec_event_or_month, has_constrained_weekday) { return function(date) {\n                    const start_of_next_year = new Date(date.getFullYear() + 1, 0, 1);\n\n                    let movableDays, from_date;\n                    if (has_event[0]) {\n                        movableDays = getMovableEventsForYear(has_year[0] ? parseInt(tokens[at][0]) : date.getFullYear());\n                        from_date = movableDays[tokens[at+has_year[0]][0]];\n\n                        if (typeof has_calc[0] === 'object' && has_calc[0][1]) {\n                            const from_year_before_calc = from_date.getFullYear();\n                            from_date.setDate(from_date.getDate() + has_calc[0][0]);\n                            if (from_year_before_calc !== from_date.getFullYear())\n                                throw formatWarnErrorMessage(nrule, at+has_year[0]+has_calc[0][1]*3,\n                                    t('movable not in year', {'name': tokens[at+has_year[0]][0], 'days': has_calc[0][0]}));\n                        }\n                    } else if (has_constrained_weekday[0]) {\n                        from_date = getDateForConstrainedWeekday((has_year[0] ? tokens[at][0] : date.getFullYear()), // year\n                            tokens[at+has_year[0]][0], // month\n                            tokens[at+has_year[0]+1][0], // weekday\n                            has_constrained_weekday[0],\n                            has_calc[0]);\n                    } else {\n                        from_date = new Date((has_year[0] ? tokens[at][0] : date.getFullYear()),\n                            tokens[at+has_year[0]][0], tokens[at+has_year[0]+1][0]);\n                    }\n\n                    let to_date;\n                    if (has_event[1]) {\n                        movableDays = getMovableEventsForYear(has_year[1]\n                                    ? parseInt(tokens[at_sec_event_or_month-1][0])\n                                    : date.getFullYear());\n                        to_date = movableDays[tokens[at_sec_event_or_month][0]];\n\n                        if (typeof has_calc[1] === 'object' && has_calc[1][1]) {\n                            const to_year_before_calc = to_date.getFullYear();\n                            to_date.setDate(to_date.getDate() + has_calc[1][0]);\n                            if (to_year_before_calc !== to_date.getFullYear()) {\n                                throw formatWarnErrorMessage(nrule, at_sec_event_or_month+has_calc[1][1],\n                                    t('movable not in year', {'name': tokens[at_sec_event_or_month][0], 'days':  has_calc[1][0] }));\n                            }\n                        }\n                    } else if (has_constrained_weekday[1]) {\n                        to_date = getDateForConstrainedWeekday((has_year[1] ? tokens[at_sec_event_or_month-1][0] : date.getFullYear()), // year\n                            tokens[at_sec_event_or_month][0],   // month\n                            tokens[at_sec_event_or_month+1][0], // weekday\n                            has_constrained_weekday[1],\n                            has_calc[1]);\n                    } else {\n                        to_date = new Date((has_year[1] ? tokens[at_sec_event_or_month-1][0] : date.getFullYear()),\n                            tokens[at_sec_event_or_month][0], tokens[at_sec_event_or_month+1][0] + 1);\n                    }\n\n                    let inside = true;\n\n                    if (to_date < from_date) {\n                        const tmp = to_date;\n                        to_date = from_date;\n                        from_date = tmp;\n                        inside = false;\n                    }\n\n                    if (date.getTime() < from_date.getTime()) {\n                        return [!inside, from_date];\n                    } else if (date.getTime() < to_date.getTime()) {\n                        return [inside, to_date];\n                    } else {\n                        if (has_year[0]) {\n                            return [!inside];\n                        } else {\n                            return [!inside, start_of_next_year];\n                        }\n                    }\n                }}(tokens, at, nrule, has_year, has_event, has_calc, at_sec_event_or_month, has_constrained_weekday);\n\n                if (push_to_month === true)\n                    rule.month.push(selector);\n                else\n                    rule.monthday.push(selector);\n\n                at = (has_constrained_weekday[1]\n                        ? has_constrained_weekday[1][1]\n                        : at_sec_event_or_month + (has_event[1] ? 1 : 2))\n                    + (typeof has_calc[1] === 'object' ? has_calc[1][1] : 0);\n\n                /* }}} */\n                // Monthday range like Jan 26-31 {{{\n            } else if (has_month[0]) {\n\n                has_year = has_year[0];\n                const year = tokens[at][0]; // Could be month if has no year. Tested later.\n                const month = tokens[at+has_year][0];\n\n                let first_round = true;\n                let is_range;\n\n                do {\n                    const range_from = tokens[at+1 + has_year][0];\n                    is_range = matchTokens(tokens, at+2+has_year, '-', 'number');\n                    let period = undefined;\n                    const range_to = tokens[at+has_year+(is_range ? 3 : 1)][0] + 1;\n                    if (is_range && matchTokens(tokens, at+has_year+4, '/', 'number')) {\n                        period = tokens[at+has_year+5][0];\n                        tokens[at+has_year+5][4] = 'positive_number';\n                        checkPeriod(at+has_year+5, period, 'day');\n                    }\n\n                    if (first_round) {\n                        const at_timesep_if_monthRange = at + has_year + 1 // at month number\n                            + (is_range ? 2 : 0) + (period ? 2 : 0)\n                            + !(is_range || period); // if not range nor has period, add one\n\n                        // Check for '<month> <timespan>'\n                        if (matchTokens(tokens, at_timesep_if_monthRange, 'timesep', 'number')\n                                && (matchTokens(tokens, at_timesep_if_monthRange+2, '+')\n                                    || matchTokens(tokens, at_timesep_if_monthRange+2, '-')\n                                    || oh_mode !== 0)\n                            ) {\n                                return parseMonthRange(tokens, at, true, true);\n                        }\n                    }\n\n                    // error checking {{{\n                    if (range_to < range_from)\n                        throw formatWarnErrorMessage(nrule, at+has_year+3, t('day range reverse'));\n\n                    checkIfDateIsValid(month, range_from, nrule, at+1 + has_year);\n                    checkIfDateIsValid(month, range_to - 1 /* added previously */,\n                        nrule, at+has_year+(is_range ? 3 : 1));\n                    /* }}} */\n\n                    const selector = function(year, has_year, month, range_from, range_to, period) { return function(date) {\n                        const start_of_next_year = new Date(date.getFullYear() + 1, 0, 1);\n\n                        const from_date = new Date(has_year ? year : date.getFullYear(),\n                            month, range_from);\n                        if (month === 1 && range_from !== from_date.getDate()) // Only on leap years does this day exist.\n                            return [false]; // If day 29 does not exist,\n                                            // then the date object adds one day to date\n                                            // and this selector should not match.\n                        const to_date   = new Date(from_date.getFullYear(),\n                            month, range_to);\n                        if (month === 1 && is_range && range_to !== to_date.getDate()) // Only on leap years does this day exist.\n                            return [false];\n\n                        if (date.getTime() < from_date.getTime())\n                            return [false, from_date];\n                        else if (date.getTime() >= to_date.getTime())\n                            return [false, start_of_next_year];\n                        else if (!period)\n                            return [true, to_date];\n\n                        const nday = Math.floor((date.getTime() - from_date.getTime()) / msec_in_day);\n                        const in_period = nday % period;\n\n                        if (in_period === 0)\n                            return [true, new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1)];\n                        else\n                            return [false, new Date(date.getFullYear(), date.getMonth(), date.getDate() + period - in_period)];\n\n                    }}(year, has_year, month, range_from, range_to, period);\n\n                    if (push_to_month === true)\n                        rule.month.push(selector);\n                    else\n                        rule.monthday.push(selector);\n\n                    at += 2 + has_year + (is_range ? 2 : 0) + (period ? 2 : 0);\n\n                    first_round = false;\n                }\n                while (matchTokens(tokens, at, ',', 'number'))\n\n\n                /* }}} */\n                // Only event like easter {{{\n            } else if (has_event[0]) {\n\n                const selector = function(tokens, at, nrule, has_year, add_days) { return function(date) {\n\n                    // console.log('enter selector with date: ' + date);\n                    const movableDays = getMovableEventsForYear((has_year ? tokens[at][0] : date.getFullYear()));\n                    const event_date = movableDays[tokens[at+has_year][0]];\n                    if (!event_date)\n                        throw t('movable no formula', {'name': tokens[at+has_year][0]});\n\n                    if (add_days[0]) {\n                        event_date.setDate(event_date.getDate() + add_days[0]);\n                        if (date.getFullYear() !== event_date.getFullYear())\n                            throw formatWarnErrorMessage(nrule, at+has_year+add_days[1], t('movable not in year', {\n                                'name': tokens[at+has_year][0], 'days': add_days[0]}));\n                    }\n\n                    if (date.getTime() < event_date.getTime())\n                        return [false, event_date];\n                    // else if (date.getTime() < event_date.getTime() + msec_in_day) // does not work because of daylight saving times\n                    else if (event_date.getMonth() * 100 + event_date.getDate() === date.getMonth() * 100 + date.getDate())\n                        return [true, new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1)];\n                    else\n                        return [false, new Date(date.getFullYear() + 1, 0, 1)];\n\n                }}(tokens, at, nrule, has_year[0], has_calc[0]);\n\n                if (push_to_month === true)\n                    rule.month.push(selector);\n                else\n                    rule.monthday.push(selector);\n\n                at += has_year[0] + has_event[0] + (typeof has_calc[0][1] === 'number' && has_calc[0][1] ? 3 : 0);\n                /* }}} */\n            } else if (has_constrained_weekday[0]) {\n                at = parseMonthRange(tokens, at);\n            } else if (matchTokens(tokens, at, 'month')) {\n                return parseMonthRange(tokens, at, true, true);\n            } else {\n                // throw 'Unexpected token in monthday range: \"' + tokens[at] + '\"';\n                return at;\n            }\n\n            if (!matchTokens(tokens, at, ','))\n                break;\n        }\n\n        return at;\n    }\n    /* }}} */\n\n    /* Main selector traversal function (return state array for date). {{{\n     * Checks for given date which rule and those which state and comment applies.\n     *\n     * :param date: Date object.\n     * :returns: Array:\n     *            0. resultstate: State: true for 'open', false for 'closed'.\n     *            1. changedate: Next change as date object.\n     *            2. unknown: true if state open is not sure.\n     *            3. comment: Comment which applies for this time range (from date to changedate).\n     *            4. match_rule: Rule number starting with 0 (nrule).\n     */\n    this.getStatePair = function(date) {\n        let resultstate = false;\n        let changedate;\n        let unknown = false;\n        let comment;\n        let match_rule;\n\n        let date_matching_rules = [];\n\n        /* Go though all date selectors and check if they return something\n         * else than closed for the given date.\n         */\n        for (let nrule = 0; nrule < rules.length; nrule++) {\n            let matching_date_rule = true;\n            // console.log(nrule, 'length',  rules[nrule].date.length);\n\n            /* Try each date selector type. */\n            for (let ndateselector = 0; ndateselector < rules[nrule].date.length; ndateselector++) {\n                const dateselectors = rules[nrule].date[ndateselector];\n                // console.log(nrule, ndateselector);\n\n                let has_matching_selector = false;\n                for (let datesel = 0; datesel < dateselectors.length; datesel++) {\n                    const res = dateselectors[datesel](date);\n                    if (res[0]) {\n                        has_matching_selector = true;\n\n                        if (typeof res[2] === 'string') { // holiday name\n                            comment = [ res[2], nrule ];\n                        }\n\n                    }\n                    if (typeof changedate === 'undefined' || (typeof res[1] === 'object' && res[1].getTime() < changedate.getTime()))\n                        changedate = res[1];\n                }\n\n                if (!has_matching_selector) {\n                    matching_date_rule = false;\n                    // We can ignore other date selectors, as the state won't change\n                    // anyway until THIS selector matches (due to conjunction of date\n                    // selectors of different types).\n                    // This is also an optimization, if widest date selector types\n                    // are checked first.\n                    break;\n                }\n            }\n\n            if (matching_date_rule) {\n                /* The following lines implement date overwriting logic (e.g. for\n                 * \"Mo-Fr 10:00-20:00; We 10:00-16:00\", We rule overrides Mo-Fr rule partly (We).\n                 *\n                 * This is the only way to be consistent. I thought about (\"22:00-02:00; Tu 12:00-14:00\") letting Th override 22:00-02:00 partly:\n                 * Like: Th 00:00-02:00,12:00-14:00 but this would result in including 22:00-00:00 for Th which is probably not what you want.\n                 */\n                if ((rules[nrule].date.length > 0 || nrule > 0 && rules[nrule].meaning && rules[nrule-1].date.length === 0)\n                        && (rules[nrule].meaning || rules[nrule].unknown)\n                        && !rules[nrule].wrapped && !rules[nrule].additional && !rules[nrule].fallback\n                    ) {\n\n                    // let old_date_matching_rules = date_matching_rules;\n                    date_matching_rules = [];\n                    // for (var nrule = 0; nrule < old_date_matching_rules.length; nrule++) {\n                    //     if (!rules[old_date_matching_rules[nrule]].wrapped)\n                    //         date_matching_rules.push(nrule);\n                    // }\n                }\n                date_matching_rules.push(nrule);\n            }\n        }\n\n        // console.log(date_matching_rules);\n        for (let nrule = 0; nrule < date_matching_rules.length; nrule++) {\n            const rule = date_matching_rules[nrule];\n\n            // console.log('Processing rule ' + rule + ': with date ' + date\n                // + ' and ' + rules[rule].time.length + ' time selectors (comment: \"' + rules[rule].comment + '\").');\n\n            /* There is no time specified, state applies to the whole day. */\n            if (rules[rule].time.length === 0) {\n                // console.log('there is no time', date);\n                if (!rules[rule].fallback || (rules[rule].fallback && !(resultstate || unknown))) {\n                    resultstate = rules[rule].meaning;\n                    unknown     = rules[rule].unknown;\n                    match_rule  = rule;\n\n                    // if (rules[rule].fallback)\n                        // break rule; // fallback rule matched, no need for checking the rest\n                    // WRONG: What if closing rules follow?\n                }\n            }\n\n            for (let timesel = 0; timesel < rules[rule].time.length; timesel++) {\n                const res = rules[rule].time[timesel](date);\n\n                // console.log('res:', res);\n                if (res[0]) {\n                    if (!rules[rule].fallback || (rules[rule].fallback && !(resultstate || unknown))) {\n                        resultstate = rules[rule].meaning;\n                        unknown     = rules[rule].unknown;\n                        match_rule  = rule;\n\n                        /* Reset open end comment */\n                        if (typeof comment === 'object' && comment[0] === t('open end'))\n                            comment = undefined;\n\n                        // open end\n                        if (res[2] === true && (resultstate || unknown)) {\n                            comment = [ t('open end'), match_rule ];\n\n                            resultstate = false;\n                            unknown     = true;\n\n                            /* Hack to make second rule in '07:00+,12:00-16:00; 16:00-24:00 closed \"needed because of open end\"' obsolete {{{ */\n                            if (typeof rules[rule].time[timesel+1] === 'function') {\n\n                                const next_res = rules[rule].time[timesel+1](date);\n                                if (  !next_res[0]\n                                    // && next_res[2]\n                                    && typeof next_res[1] === 'object'\n                                    // && getValueForDate(next_res[1], true) !== getValueForDate(date, true) // Just to be sure.\n                                    && rules[rule].time[timesel](new Date(date.getTime() - 1))[0]\n                                    /* To distinguish the following two values:\n                                     *     'sunrise-14:00,14:00+',\n                                     *   '07:00+,12:00-16:00',\n                                     */\n                                    ) {\n\n                                    // console.log(\"07:00+,12:00-16:00 matched.\");\n\n                                    resultstate = false;\n                                    unknown     = false;\n                                }\n                            }\n\n                            /* Hack to handle '17:00+,13:00-02:00' {{{ */\n                            /* Not enabled. To complicated, just don‘t use them …\n                             * It gets even crazier …\n                             * Time wrapping over midnight is\n                             * stored in the next internal rule:\n                             * '17:00-00:00 unknown \"Specified as open end. Closing time was guessed.\", 13:00-00:00 open' // First internal rule.\n                             * + ', ' overwritten part: 00:00-03:00 open + '00:00-02:00 open', // Second internal rule.\n                             */\n\n                            /*\n                            if (\n                                    typeof rules[rule-1] === 'object'\n                                    && rules[rule].build_from_token_rule.toString() === rules[rule-1].build_from_token_rule.toString()\n                                    && typeof rules[rule] === 'object'\n                                    && rules[rule].build_from_token_rule.toString() === rules[rule].build_from_token_rule.toString()\n                                    ) {\n\n                                let last_wrapping_time_selector = rules[rule].time[rules[rule].time.length - 1];\n                                let last_w_res = last_wrapping_time_selector(new Date(date.getTime() - 1));\n                                // console.log(last_w_res);\n\n                                if (    last_w_res[0]\n                                        &&  typeof last_w_res[2] === 'undefined'\n                                        && (typeof last_w_res[2] === 'undefined' || last_w_res[2] === false) // Do not match for 'Tu 23:59-40:00+'\n                                        &&  typeof last_w_res[1] === 'object'\n                                        && date.getTime() === last_w_res[1].getTime()\n                                    ) {\n\n                                    // '05:00-06:00,17:00+,13:00-02:00',\n\n                                    // console.log(\"17:00+,13:00-02:00 matched.\");\n                                    // console.log(JSON.stringify(rules, null, '    '));\n\n                                    resultstate = false;\n                                    unknown     = false;\n                                }\n                            }\n                            /* }}} */\n                        }\n\n                        if (rules[rule].fallback) {\n                            if (typeof changedate === 'undefined' || (typeof res[1] !== 'undefined' && res[1] < changedate)) {\n                                // FIXME: Changing undefined does not break the test framework.\n                                changedate = res[1];\n                            }\n\n                            // break rule; // Fallback rule matched, no need for checking the rest.\n                            // WRONG: What if 'off' is used after fallback rule.\n                        }\n                    }\n                }\n                if (typeof changedate === 'undefined' || (typeof res[1] === 'object' && res[1] < changedate))\n                    changedate = res[1];\n            }\n        }\n\n        if (typeof rules[match_rule] === 'object' && typeof rules[match_rule].comment === 'string') {\n            /* Only use comment if one is explicitly specified. */\n            comment = rules[match_rule].comment;\n        } else if (typeof comment === 'object') {\n            if (comment[1] === match_rule) {\n                comment = comment[0];\n            } else {\n                comment = undefined;\n            }\n        }\n\n        // console.log('changedate', changedate, resultstate, comment, match_rule);\n        return [ resultstate, changedate, unknown, comment, match_rule ];\n    };\n    /* }}} */\n\n    /* Generate prettified value for selector based on tokens. {{{\n     *\n     * :param tokens: List of token objects.\n     * :param at: Position where to start.\n     * :param last_at: Position where to stop.\n     * :param conf: Configuration options.\n     * :returns: Prettified value.\n     */\n    function prettifySelector(tokens, selector_start, selector_end, selector_type, conf) {\n\n        let prettified_value = '';\n        let at = selector_start;\n        // console.log(selector_type);\n        while (at <= selector_end) {\n            // console.log('At: ' + at + ', token: ' + tokens[at]);\n            if (matchTokens(tokens, at, 'weekday')) {\n                if (!conf.leave_weekday_sep_one_day_betw\n                    && at - selector_start > 1 && (matchTokens(tokens, at-1, ',') || matchTokens(tokens, at-1, '-'))\n                    && matchTokens(tokens, at-2, 'weekday')\n                    && tokens[at][0] === (tokens[at-2][0] + 1) % 7) {\n                        prettified_value = prettified_value.substring(0, prettified_value.length - 1) + conf.sep_one_day_between;\n                }\n                prettified_value += weekdays[tokens[at][0]];\n            } else if (at - selector_start > 0 // e.g. '09:0' -> '09:00'\n                    && selector_type === 'time'\n                    && matchTokens(tokens, at-1, 'timesep')\n                    && matchTokens(tokens, at, 'number')) {\n                prettified_value += (tokens[at][0] < 10 ? '0' : '') + tokens[at][0].toString();\n            } else if (selector_type === 'time' // e.g. '9:00' -> ' 09:00'\n                    && conf.zero_pad_hour\n                    && at !== tokens.length\n                    && matchTokens(tokens, at, 'number')\n                    && matchTokens(tokens, at+1, 'timesep')) {\n                prettified_value += (\n                        tokens[at][0] < 10 ?\n                            (tokens[at][0] === 0 && conf.one_zero_if_hour_zero ?\n                             '' : '0') :\n                            '') + tokens[at][0].toString();\n            } else if (selector_type === 'time' // e.g. '9-18' -> '09:00-18:00'\n                    && at + 2 <= selector_end\n                    && matchTokens(tokens, at, 'number')\n                    && matchTokens(tokens, at+1, '-')\n                    && matchTokens(tokens, at+2, 'number')) {\n                prettified_value += (tokens[at][0] < 10 ?\n                        (tokens[at][0] === 0 && conf.one_zero_if_hour_zero ? '' : '0')\n                        : '') + tokens[at][0].toString();\n                prettified_value += ':00-'\n                    + (tokens[at+2][0] < 10 ? '0' : '') + tokens[at+2][0].toString()\n                    + ':00';\n                at += 2;\n            } else if (matchTokens(tokens, at, 'comment')) {\n                prettified_value += '\"' + tokens[at][0].toString() + '\"';\n            } else if (matchTokens(tokens, at, 'closed')) {\n                prettified_value += (conf.leave_off_closed ? tokens[at][0] : conf.keyword_for_off_closed);\n            } else if (at - selector_start > 0 && matchTokens(tokens, at, 'number')\n                    && (selector_type === 'month' || selector_type === 'week')) {\n                prettified_value +=\n                    (matchTokens(tokens, at-1, 'month') || matchTokens(tokens, at-1, 'week') ? ' ' : '')\n                    + (conf.zero_pad_month_and_week_numbers && tokens[at][4] !== 'positive_number' && tokens[at][0] < 10 ? '0' : '')\n                    + tokens[at][0];\n            } else if (at - selector_start > 0 && matchTokens(tokens, at, 'month')\n                    && matchTokens(tokens, at-1, 'year')) {\n                prettified_value += ' ' + months[[tokens[at][0]]];\n            } else if (at - selector_start > 0 && matchTokens(tokens, at, 'event')\n                    && matchTokens(tokens, at-1, 'year')) {\n                prettified_value += ' ' + tokens[at][0];\n            } else if (matchTokens(tokens, at, 'month')) {\n                prettified_value += months[[tokens[at][0]]];\n                if (at + 1 <= selector_end && matchTokens(tokens, at+1, 'weekday'))\n                    prettified_value += ' ';\n            } else if (at + 2 <= selector_end\n                    && (matchTokens(tokens, at, '-') || matchTokens(tokens, at, '+'))\n                    && matchTokens(tokens, at+1, 'number', 'calcday')) {\n                prettified_value += ' ' + tokens[at][0] + tokens[at+1][0] + ' day' + (Math.abs(tokens[at+1][0]) === 1 ? '' : 's');\n                at += 2;\n            } else if (at === selector_end\n                    && selector_type === 'weekday'\n                    && tokens[at][0] === ':') {\n                // Do nothing.\n            } else if (at === selector_end\n                    && selector_type === 'time'\n                    && tokens[at][0] === ',') {\n                /* Remove trailing , which is ignored in parseTimeRange. */\n            } else {\n                prettified_value += tokens[at][0].toString();\n            }\n            at++;\n        }\n        return prettified_value;\n    }\n    /* }}} */\n\n    //======================================================================\n    // Public interface {{{\n    // All functions below are considered public.\n    //======================================================================\n\n    // Simple API {{{\n\n    this.getState = function(date) {\n        const it = this.getIterator(date);\n        return it.getState();\n    };\n\n    this.getUnknown = function(date) {\n        const it = this.getIterator(date);\n        return it.getUnknown();\n    };\n\n    this.getStateString = function(date, past) {\n        const it = this.getIterator(date);\n        return it.getStateString(past);\n    };\n\n    this.getComment = function(date) {\n        const it = this.getIterator(date);\n        return it.getComment();\n    };\n\n    this.getMatchingRule = function(date) {\n        const it = this.getIterator(date);\n        return it.getMatchingRule();\n    };\n\n    /* Not available for iterator API {{{ */\n    /* getWarnings: Get warnings, empty list if none {{{ */\n    this.getWarnings = function() {\n        const it = this.getIterator();\n        return getWarnings(it);\n    };\n    /* }}} */\n\n    /* prettifyValue: Get a nicely formated value {{{ */\n    this.prettifyValue = function(argument_hash) {\n        this.getWarnings();\n        /* getWarnings has to be run before prettifyValue because some\n         * decisions if certain aspects makes sense to prettify or not\n         * are influenced by warnings.\n         * Basically, both functions depend on each other in some way :(\n         * See done_with_selector_reordering.\n         */\n        return prettifyValue(argument_hash);\n    };\n    /* }}} */\n\n    /* getNextChange: Get time of next status change {{{ */\n    this.getNextChange = function(date, maxdate) {\n        const it = this.getIterator(date);\n        if (!it.advance(maxdate))\n            return undefined;\n        return it.getDate();\n    };\n    /* }}} */\n\n    /* isWeekStable: Checks whether open intervals are same for every week. {{{ */\n    this.isWeekStable = function() {\n        return week_stable;\n    };\n    /* }}} */\n\n    /* isEqualTo: Check if this opening_hours object has the same meaning as the given opening_hours object. {{{ */\n    this.isEqualTo = function(second_oh_object, start_date) {\n        if (typeof start_date === 'undefined') {\n            start_date = new Date();\n        }\n        let datelimit;\n\n        if (this.isWeekStable() && second_oh_object.isWeekStable()) {\n            datelimit = new Date(start_date.getTime() + msec_in_day * 10);\n        // } else if (this.isWeekStable() !== second_oh_object.isWeekStable()) {\n        //     return [ false,\n        //         {\n        //             'reason': 'isWeekStable do not match',\n        //         }\n        //     ];\n        } else {\n            datelimit = new Date(start_date.getTime() + msec_in_day * 366 * 5);\n        }\n\n        const first_it = this.getIterator(start_date);\n        const second_it = second_oh_object.getIterator(start_date);\n\n        while (first_it.advance(datelimit)) {\n            second_it.advance(datelimit);\n\n            const not_equal = [];\n\n            if (first_it.getDate().getTime() !== second_it.getDate().getTime()) {\n                not_equal.push('getDate');\n            }\n\n            if (first_it.getState() !== second_it.getState()) {\n                not_equal.push('getState');\n            }\n\n            if (first_it.getUnknown() !== second_it.getUnknown()) {\n                not_equal.push('getUnknown');\n            }\n\n            if (first_it.getComment() !== second_it.getComment()) {\n                not_equal.push('getComment');\n            }\n\n            if (not_equal.length) {\n                const deviation_for_time = {};\n                deviation_for_time[first_it.getDate().getTime()] = not_equal;\n                return [ false,\n                    {\n                        'matching_rule': first_it.getMatchingRule(),\n                        'matching_rule_other': second_it.getMatchingRule(),\n                        'deviation_for_time': deviation_for_time,\n                    }\n                ];\n            }\n        }\n\n        return [ true ];\n    };\n    /* }}} */\n    /* }}} */\n    /* }}} */\n\n    // High-level API {{{\n    /* getOpenIntervals: Get array of open intervals between two dates {{{ */\n    this.getOpenIntervals = function(from, to) {\n        const res = [];\n\n        const it = this.getIterator(from);\n\n        if (it.getState() || it.getUnknown()) {\n            res.push([from, undefined, it.getUnknown(), it.getComment()]);\n        }\n\n        while (it.advance(to)) {\n            if (it.getState() || it.getUnknown()) {\n                if (res.length !== 0 && typeof res[res.length - 1][1] === 'undefined') {\n                    // last state was also open or unknown\n                    res[res.length - 1][1] = it.getDate();\n                }\n                res.push([it.getDate(), undefined, it.getUnknown(), it.getComment()]);\n            } else {\n                if (res.length !== 0 && typeof res[res.length - 1][1] === 'undefined') {\n                    // only use the first time as closing/change time and ignore closing times which might follow\n                    res[res.length - 1][1] = it.getDate();\n                }\n            }\n        }\n\n        if (res.length > 0 && typeof res[res.length - 1][1] === 'undefined') {\n            res[res.length - 1][1] = to;\n        }\n\n        return res;\n    };\n    /* }}} */\n\n    /* getOpenDuration: Get total number of milliseconds a facility is open,unknown within a given date range {{{ */\n    this.getOpenDuration = function(from, to) {\n\n        let open    = 0;\n        let unknown = 0;\n\n        const it = this.getIterator(from);\n        let prevdate    = (it.getState() || it.getUnknown()) ? from : undefined;\n        let prevstate   = it.getState();\n        let prevunknown = it.getUnknown();\n\n        while (it.advance(to)) {\n            if (it.getState() || it.getUnknown()) {\n\n                if (typeof prevdate === 'object') {\n                    // last state was also open or unknown\n                    if (prevunknown) //\n                        unknown += it.getDate().getTime() - prevdate.getTime();\n                    else if (prevstate)\n                        open    += it.getDate().getTime() - prevdate.getTime();\n                }\n\n                prevdate    = it.getDate();\n                prevstate   = it.getState();\n                prevunknown = it.getUnknown();\n                // console.log('if', prevdate, open / (1000 * 60 * 60), unknown / (1000 * 60 * 60));\n            } else {\n                // console.log('else', prevdate);\n                if (typeof prevdate === 'object') {\n                    if (prevunknown)\n                        unknown += it.getDate().getTime() - prevdate.getTime();\n                    else\n                        open    += it.getDate().getTime() - prevdate.getTime();\n                    prevdate = undefined;\n                }\n            }\n        }\n\n        if (typeof prevdate === 'object') {\n            if (prevunknown)\n                unknown += to.getTime() - prevdate.getTime();\n            else\n                open    += to.getTime() - prevdate.getTime();\n        }\n\n        return [ open, unknown ];\n    };\n    /* }}} */\n    /* }}} */\n\n    // Iterator API {{{\n    this.getIterator = function(date) {\n        return new function(oh) {\n            if (typeof date === 'undefined')\n                date = new Date();\n\n            let prevstate = [ undefined, date, undefined, undefined, undefined ];\n            let state = oh.getStatePair(date);\n\n            /* getDate {{{ */\n            this.getDate = function() {\n                return prevstate[1];\n            };\n            /* }}} */\n\n            /* setDate {{{ */\n            this.setDate = function(date) {\n                if (typeof date !== 'object')\n                    throw t('date parameter needed');\n\n                prevstate = [ undefined, date, undefined, undefined, undefined ];\n                state     = oh.getStatePair(date);\n            };\n            /* }}} */\n\n            /* getState: Check whether facility is `open' {{{ */\n            this.getState = function() {\n                return state[0];\n            };\n            /* }}} */\n\n            /* getUnknown: Checks whether the opening state is conditional or unknown {{{ */\n            this.getUnknown = function() {\n                return state[2];\n            };\n            /* }}} */\n\n            /* getStateString: Get state string. Either 'open', 'unknown' or 'closed' {{{ */\n            this.getStateString = function(past) {\n                return (state[0] ? 'open' : (state[2] ? 'unknown' : (past ? 'closed' : 'close')));\n            };\n            /* }}} */\n\n            /* getComment: Get the comment, undefined in none {{{ */\n            this.getComment = function() {\n                return state[3];\n            };\n            /* }}} */\n\n            /* getMatchingRule: Get the rule which matched thus deterrents the current state {{{ */\n            this.getMatchingRule = function() {\n                if (typeof state[4] === 'undefined')\n                    return undefined;\n\n                return rules[state[4]].build_from_token_rule[2];\n            };\n            /* }}} */\n\n            /* advance: Advances to the next position {{{ */\n            this.advance = function(datelimit) {\n                if (typeof datelimit === 'undefined') {\n                    datelimit = new Date(prevstate[1].getTime() + msec_in_day * 366 * 5);\n                } else if (datelimit.getTime() <= prevstate[1].getTime()) {\n                    return false; /* The limit for advance needs to be after the current time. */\n                }\n\n                do {\n                    if (typeof state[1] === 'undefined') {\n                        return false; /* open range, we won't be able to advance */\n                    }\n\n                    // console.log('\\n' + 'previous check time:', prevstate[1]\n                    //     + ', current check time:',\n                    //     state[1],\n                    //     (state[0] ? 'open' : (state[2] ? 'unknown' : 'closed'))\n                    //     + ', comment:', state[3]\n                    //     + ', match_rule:', state[4]);\n\n                    if (state[1].getTime() <= prevstate[1].getTime()) {\n                        /* We're going backwards or staying at the same time.\n                         * This most likely indicates an error in a selector code.\n                         */\n                        throw 'Fatal: infinite loop in nextChange';\n                    }\n\n                    if (state[1].getTime() >= datelimit.getTime()) {\n                        /* Don't advance beyond limits. */\n                        return false;\n                    }\n\n                    // do advance\n                    prevstate = state;\n                    state = oh.getStatePair(prevstate[1]);\n                    // console.log(state);\n                } while (state[0] === prevstate[0] && state[2] === prevstate[2] && state[3] === prevstate[3]);\n                return true;\n            };\n            /* }}} */\n        }(this);\n    };\n    /* }}} */\n\n    /* }}} */\n}\n\n/* vim: set ts=4 sw=4 tw=0 et foldmarker={{{,}}} foldlevel=0 foldmethod=marker : */\n"],"names":["i18next","isInitialized","lang","opening_hours_resources","addResourceBundle","init","fallbackLng","resources","getAsync","useCookie","value","nominatim_object","optional_conf_parm","word_value_replacement","dawn","sunrise","sunset","dusk","months","weekdays","string_to_token_map","su","mo","tu","we","th","fr","sa","jan","feb","mar","apr","may","jun","jul","aug","sep","oct","nov","dec","day","days","easter","week","open","closed","off","unknown","default_prettify_conf","zero_pad_hour","one_zero_if_hour_zero","leave_off_closed","keyword_for_off_closed","rule_sep_string","print_semicolon","leave_weekday_sep_one_day_betw","sep_one_day_between","zero_pad_month_and_week_numbers","locale","date_format","osm_tag_defaults","opening_hours","mode","warn_for_PH_missing","collection_times","smoking_hours","service_times","happy_hours","lit","map","yes","automatic","no","interval","limited","minutes_in_day","msec_in_day","library_name","repository_url","language","t","str","variables","indexOf","translatorFunction","getFixedT","text","replace","match","c","location_cc","location_state","lat","lon","address","country_code","state","county","oh_mode","oh_key","oh_regex_key","warnings_severity","oh_map_value","split","checkOptionalConfParm","severity","allowed","map_value","given","key","regex_key","exact_match","Object","keys","forEach","osm_key","RegExp","test","getRegexKeyForKeyFromOsmDefaults","undefined","parsing_warnings","done_with_warnings","done_with_selector_reordering","done_with_selector_reordering_warnings","tokens","tokenize","all_tokens","curr_rule_tokens","last_rule_fallback_terminated","token_from_map","tmp","toLowerCase","push","concat","length","substr","toUpperCase","unicode_code_point_to_digit","regular_number","ch","code_point","charCodeAt","join","ok","matchTokens","i","ko","correct_val","returnCorrectWordOrToken","hours_token","hours_token_at","correct_tokens","formatLibraryBugMessage","Number","number","formatWarnErrorMessage","pos","rule","nrule","prettified_value","week_stable","rules","rule_infos","new_tokens","continue_at","next_rule_is_additional","time","wraptime","weekday","holiday","month","monthday","year","date","fallback","additional","meaning","comment","build_from_token_rule","parseGroup","slice","unshift","pop","element","wrapselectors","wrapped","dselg","dsel","generateDateShifter","expected_type","expected","at","message","tokens_to_use","console","warn","JSON","stringify","log","substring","text_template","url","error","word","value_length","correctWordOrToken","word_error_correction","old_val","val","getWarnings","it","wide_range_selector_order","small_range_selector_order","used_selectors","used_selectors_types_array","has_token","selector_start_end_type","getSelectorRange","token_pos","selector_type","count","part2","what","next_selector_type","rules_too_complex_count","filter","el","next_rule_selects_next_day","week_day","additional_rule_separator_enabled","additional_rule_separator","advance","keys_with_warn_for_PH_missing","prettifyValue","warnings","tokenIsTheBeginOfSelector","selector_end","pos_in_token_array","selector_start","argument_hash","rule_index","user_conf","get_internals","prettified_value_array","conf","_is_en_or_all","months_local","Date","toLocaleString","weekdays_local","prettified_group_value","prettifySelector","not_sorted_prettified_group_value","sort","a","b","selector_order","old_prettified_value_length","type","array","l","x","first","second","arguments","func","shift","res","getTime","rule_modifier_specified","last_selector","parseWeekdayRange","parseHoliday","parseMonthdayRange","parseYearRange","parseMonthRange","parseWeekRange","parseTimeRange","token","dateAtDayMinutes","minutes","getFullYear","getMonth","getDate","dateAtNextWeekday","delta","getDay","parseNumRange","getConstrainedWeekday","endat","from","to","symbol","checkPeriod","period","period_type","parm_string","getDateForConstrainedWeekday","constrained_weekday","add_days","tmp_date","setDate","checkIfDateIsValid","extended_open_end","has_time_var_calc","has_normal_time","minutes_from","minutes_to","has_open_end","is_point_in_time","timevar_add","point_in_time_period","timevar_string","getMinutesByHoursMinutes","parseTimevarCalc","at_end_time","calc","libraryname","ourminutes","getHours","getMinutes","date_from","SunCalc","getTimes","date_to","cur_min","syntax","add_or_subtract","in_holiday_selector","numbers","getMoveDays","nnumber","date_num","getValueForDate","start_of_this_month","start_of_next_month","target_day_this_month","target_day_with_added_moved_days_this_month","target_day_with_added_days_this_month","currentDateOnly","targetDateOnly","is_range","weekday_from","weekday_to","inside","weekday_list","Array","apply","_","index","prototype","ourweekday","max_differ","name","maxdiffer","push_to_weekday","applying_holidays","getMatchingHoliday","selector","holidays","getApplyingHolidaysForYear","next_holiday_date_num","holidays_last_year","last_holiday_last_year","last_holiday_last_year_num","first_holidays_next_year","getSHForYear","h","holiday_to_plus","holiday_from","holiday_to","holiday_ends_next_year","last_year_holiday","last_year_holiday_from","last_year_holiday_to","include_year","SH_hash","fatal","type_of_holidays","holiday_definitions","cc","matching_holiday","country_holidays","state_holidays","country_holiday_names","country_holiday","state_holiday","h1","h2","h1_year","find","k","h2_year","h1_date","h2_date","applying_holidays_for_country","holiday_item","only_states","getMovableEventsForYear","C","Math","floor","N","K","I","J","L","M","D","oD","oF","oDate","lastFebruaryDay","lastFebruarySunday","victoriaDay","canadaDay","firstWeekdayOfMonth","lastWeekdayOfMonth","last","offset","getDateOfWeekdayInDateRange","start_date","days_to_dest_date","getDateOfNextWeekdayRange","first_weekday","last_weekday","firstJanuaryMonday","firstFebruaryMonday","firstMarchMonday","firstAprilMonday","firstMayMonday","firstJuneMonday","firstJulyMonday","firstAugustMonday","firstSeptemberMonday","firstSeptemberTuesday","firstSeptemberSunday","firstOctoberMonday","firstNovemberMonday","firstNovemberTuesday","firstMarchTuesday","firstAugustTuesday","firstAugustFriday","firstNovemberThursday","lastMayMonday","lastMarchMonday","lastAprilMonday","lastAprilFriday","lastAugustMonday","lastSeptemberMonday","lastSeptemberFriday","lastOctoberMonday","lastOctoberFriday","nextSaturday20Jun","nextSaturday31Oct","nextWednesday16Nov","springEquinox","springEquinoxCalc","autumnalEquinox","autumnalEquinoxCalc","movableDays","next_holiday","sorted_holidays","fixed_date","selected_movableDay","variable_date","date_offset","has_period","parseInt","year_from","ouryear","year_to","week_from","week_to","weekfrom","weekto","ourweek","getWeekNumber","getNextDateOfISOWeek","next_matching_week","d","setHours","yearStart","ceil","getDateOfISOWeek","w","simple","dow","ISOweekStart","next_date","push_to_monthday","in_selector","month_from","month_to","ourmonth","dateAtNextMonth","push_to_month","has_year","has_month","has_event","has_calc","has_constrained_weekday","at_range_sep","at_sec_event_or_month","start_of_next_year","from_date","to_date","from_year_before_calc","to_year_before_calc","first_round","range_from","range_to","at_timesep_if_monthRange","in_period","event_date","toString","abs","this","getStatePair","changedate","match_rule","resultstate","date_matching_rules","matching_date_rule","ndateselector","dateselectors","has_matching_selector","datesel","timesel","next_res","getState","getIterator","getUnknown","getStateString","past","getComment","getMatchingRule","getNextChange","maxdate","isWeekStable","isEqualTo","second_oh_object","datelimit","first_it","second_it","not_equal","deviation_for_time","matching_rule","matching_rule_other","getOpenIntervals","getOpenDuration","prevdate","prevstate","prevunknown","oh"],"mappings":"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"}